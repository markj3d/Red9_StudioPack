<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Red9_Meta &mdash; Red9 3.0 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Red9_PoseSaver" href="Red9_PoseSaver.html" />
    <link rel="prev" title="Red9_General" href="Red9_General.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Red9<img src="../_static/Red9_ProPack_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Red9_AnimationUtils.html">Red9_AnimationUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Audio.html">Red9_Audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Core.html">Red9_CoreUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_General.html">Red9_General</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Red9_Meta</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_PoseSaver.html">Red9_PoseSaver</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Setup.html">Red9_Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Tools.html">Red9_Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_anim_map.html">Pro_Pack : anim_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_animation.html">Pro_Pack : animation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_audio.html">Pro_Pack : audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_export.html">Pro_Pack : exporter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_general.html">Pro_Pack : general</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_importexport.html">Pro_Pack : importexport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_metadata_pro.html">Pro_Pack : metadata_pro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_optimiser.html">Pro_Pack : optimiser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_project.html">Pro_Pack : project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_r9data.html">Pro_Pack : r9Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_rigutils.html">Pro_Pack : rigutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_skining.html">Pro_Pack : skining</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_skinning.html">Pro_Pack : skinning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/Red9_Pro_uibase.html">Pro_Pack : uibase</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/tools/Red9_Pro_anim_binder.html">Pro_Pack : tools : anim_binder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/tools/Red9_Pro_anim_tools.html">Pro_Pack : tools : anim_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/tools/Red9_Pro_health_manager.html">Pro_Pack : tools : health_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/tools/Red9_Pro_metahuman_tools.html">Pro_Pack : tools : metahuman_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/tools/Red9_Pro_project_manager.html">Pro_Pack : tools : project_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/tools/Red9_Pro_rig_manager.html">Pro_Pack : tools : rig_manager</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../red9pro_templates/puppet/Red9_Pro_ikfk_match.html">Pro_Pack : puppet : ikfk_match</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Red9</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Red9_Meta</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/red9core_templates/Red9_Meta.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <a class="reference external image-reference" href="http://red9consultancy.com/propack"><img alt="red9core_templates\../../_images/Red9_ProPack_strap_pro.png" src="red9core_templates\../../_images/Red9_ProPack_strap_pro.png" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="red9-meta">
<h1>Red9_Meta<a class="headerlink" href="#red9-meta" title="Permalink to this headline">¶</a></h1>
<p>Red9 Meta is a full metaData API that deals with Maya nodes in a more seamless manor. I’ve
tried to do as much documentation as I can both in terms of commenting the code and doing
examples and Vimeo demos.</p>
<p>This is a big concept and at the very core of the Red9 ProPack codebase.</p>
<p><strong>Vimeo Demos:</strong></p>
<ul class="simple">
<li>Develop Conference 2014 - MetaData in a Production Pipeline Video1 <a class="reference external" href="https://vimeo.com/100882408">https://vimeo.com/100882408</a></li>
<li>Develop Conference 2014 - MetaData in a Production Pipeline Video2 <a class="reference external" href="https://vimeo.com/100883383">https://vimeo.com/100883383</a></li>
<li>Develop Conference 2014 - MetaData in a Production Pipeline Video3 <a class="reference external" href="https://vimeo.com/102463373">https://vimeo.com/102463373</a></li>
<li>MetaData part1 <a class="reference external" href="https://vimeo.com/61841345">https://vimeo.com/61841345</a></li>
<li>MetaData part2 <a class="reference external" href="https://vimeo.com/62546103">https://vimeo.com/62546103</a></li>
<li>MetaData Part3 <a class="reference external" href="https://vimeo.com/64258996">https://vimeo.com/64258996</a></li>
<li>MetaData part4 <a class="reference external" href="https://vimeo.com/72006183">https://vimeo.com/72006183</a></li>
<li>MetaData MetaHUD <a class="reference external" href="https://vimeo.com/65006622">https://vimeo.com/65006622</a></li>
</ul>
<p>There are also some basic examples in the Red9 Package itself found under the examples folder.</p>
<span class="target" id="module-Red9.core.Red9_Meta"></span><p><strong>Basic MetaClass Use:</strong></p>
<p>Now moved to the examples folder for more detailed explanations
If viewing this from ProPack make sure to checkout the pro_pack/devkit folder</p>
<ul class="simple">
<li><em>Red9/examples/MetaData_Getting_started.py</em></li>
<li><em>Red9/examples/MetaRig_Morpheus.py</em></li>
</ul>
<p>Also see the unittesting folder to see what the code can do and
what each function is expected to return</p>
<ul class="simple">
<li><em>Red9/tests</em></li>
</ul>
<p class="rubric">Key Functions</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.registerMClassInheritanceMapping" title="Red9.core.Red9_Meta.registerMClassInheritanceMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">registerMClassInheritanceMapping</span></code></a>()</td>
<td>build up the master global registry of all available subclasses from r9Meta.MetaClass, this build up 2 global dicts: RED9_META_REGISTERY : {‘className’: class pointer} RED9_META_INHERITANCE_MAP : {‘className’: {‘full’: [list of inherited class pointers]},                                           {‘short’: [list of inherited class.__names__]}}</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.registerMClassNodeMapping" title="Red9.core.Red9_Meta.registerMClassNodeMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">registerMClassNodeMapping</span></code></a>([nodeTypes])</td>
<td>Hook to allow you to extend the type of nodes included in all the getMeta searches.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.isMetaNode" title="Red9.core.Red9_Meta.isMetaNode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isMetaNode</span></code></a>(node[,&nbsp;mTypes,&nbsp;checkInstance,&nbsp;…])</td>
<td>Simple bool, Maya Node is or isn’t an mNode</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.isMetaNodeInherited" title="Red9.core.Red9_Meta.isMetaNodeInherited"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isMetaNodeInherited</span></code></a>(node[,&nbsp;mInstances,&nbsp;mode])</td>
<td>unlike isMetaNode which checks the node against a particular MetaClass, this expands the check to see if the node is inherited from or a subclass of a given Meta base class, ie, part of a system</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.getMetaNodes" title="Red9.core.Red9_Meta.getMetaNodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMetaNodes</span></code></a>([mTypes,&nbsp;mInstances,&nbsp;…])</td>
<td>Get all mClass nodes in scene and return as mClass objects if possible</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.getMetaRigs" title="Red9.core.Red9_Meta.getMetaRigs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMetaRigs</span></code></a>([mInstances,&nbsp;mClassGrps])</td>
<td>Wrapper over the get call to fire back specifically MetaRigs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.getMetaRigs_fromSelected" title="Red9.core.Red9_Meta.getMetaRigs_fromSelected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMetaRigs_fromSelected</span></code></a>([singular])</td>
<td>light wrap over the getMetaRigs function to return a list of mRigs connected to the selected nodes</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.getConnectedMetaNodes" title="Red9.core.Red9_Meta.getConnectedMetaNodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getConnectedMetaNodes</span></code></a>(nodes[,&nbsp;source,&nbsp;…])</td>
<td>From a given set of Maya Nodes return all connected mNodes Default return is mClass objects</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.getConnectedMetaSystemRoot" title="Red9.core.Red9_Meta.getConnectedMetaSystemRoot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getConnectedMetaSystemRoot</span></code></a>(node[,&nbsp;mTypes,&nbsp;…])</td>
<td>From a given node see if it’s part of a MetaData system, if so walk up the parent tree till you get to top meta node and return the class.</td>
</tr>
</tbody>
</table>
<p class="rubric">Main Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaClass</span></code></a>([node,&nbsp;name,&nbsp;nodeType,&nbsp;autofill])</td>
<td>Base Class for Meta support.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaRig</span></code></a>(*args,&nbsp;**kws)</td>
<td>Sub-class of Meta used as the back-bone of our internal rigging systems.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaRigSubSystem" title="Red9.core.Red9_Meta.MetaRigSubSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaRigSubSystem</span></code></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MRig, designed to organize Rig sub-systems (ie L_ArmSystem, L_LegSystem..) within a complex rig structure.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaRigSupport" title="Red9.core.Red9_Meta.MetaRigSupport"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaRigSupport</span></code></a>(*args,&nbsp;**kws)</td>
<td>SubClass of MetaClass, designed to organize support nodes, solvers and other internal nodes within a complex rig structure which you may need to ID at a later date.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaFacialRig" title="Red9.core.Red9_Meta.MetaFacialRig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaFacialRig</span></code></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MetaRig, designed to be manage Facial systems in the MetaData Dag tree for organizing Facial Controllers and support nodes</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaFacialRigSupport" title="Red9.core.Red9_Meta.MetaFacialRigSupport"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaFacialRigSupport</span></code></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MetaClass, designed to organize support nodes, solvers and other internal nodes within a complex rig structure which you may need to ID at a later date.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode" title="Red9.core.Red9_Meta.MetaHIKCharacterNode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaHIKCharacterNode</span></code></a>(*args,&nbsp;**kws)</td>
<td>Casting HIK directly to a metaClass so it’s treated as meta by default.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaHIKControlSetNode" title="Red9.core.Red9_Meta.MetaHIKControlSetNode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaHIKControlSetNode</span></code></a>(*args,&nbsp;**kws)</td>
<td>Casting HIK directly to a metaClass so it’s treated as meta by default.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode" title="Red9.core.Red9_Meta.MetaHIKPropertiesNode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaHIKPropertiesNode</span></code></a>(*args,&nbsp;**kws)</td>
<td>Casting HIK Properties to a Meta class for easy managing</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.core.Red9_Meta.MetaHUDNode" title="Red9.core.Red9_Meta.MetaHUDNode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaHUDNode</span></code></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MetaClass, designed as a simple interface for HUD management in Maya.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaTimeCodeHUD</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="Red9.core.Red9_Meta.logging_is_debug">
<code class="descname">logging_is_debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.logging_is_debug" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.registerMClassInheritanceMapping">
<code class="descname">registerMClassInheritanceMapping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.registerMClassInheritanceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>build up the master global registry of all available subclasses from r9Meta.MetaClass,
this build up 2 global dicts:
RED9_META_REGISTERY : {‘className’: class pointer}
RED9_META_INHERITANCE_MAP : {‘className’: {‘full’: [list of inherited class pointers]},</p>
<blockquote>
<div>{‘short’: [list of inherited class.__names__]}}</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.printSubClassRegistry">
<code class="descname">printSubClassRegistry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.printSubClassRegistry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassMetaRegistry">
<code class="descname">getMClassMetaRegistry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassMetaRegistry" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic getWrapper to return the Registry from the global</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassMetaRegistry_FromKey">
<code class="descname">getMClassMetaRegistry_FromKey</code><span class="sig-paren">(</span><em>mClass</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassMetaRegistry_FromKey" title="Permalink to this definition">¶</a></dt>
<dd><p>new function to get the mClass object, this is needed if we end up
running the test versioning setup in the registery’s</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.create_mNode_from_gatherInfo">
<code class="descname">create_mNode_from_gatherInfo</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.create_mNode_from_gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>a simple wrapper to re-construct the correct mNode from a dict() built by
the MetaClass.gatherInfo_mNode() call. This is primarily aimed at the new
load_connection_datamap call in ProPack to rebuild entire networks from a
map file without having to write complex macros to rebuild a system and
all it’s wiring.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassInstances">
<code class="descname">getMClassInstances</code><span class="sig-paren">(</span><em>mInstances</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>return a list of Registered metaClasses that are subclassed from the given
classes. This is so in code/UI’s you can group metaClasses by their
inheritance … ie, give me all export metaClasses that are registered</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mInstanes</strong> – given metaClass to test inheritance - cls or [cls]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.mTypesToRegistryKey">
<code class="descname">mTypesToRegistryKey</code><span class="sig-paren">(</span><em>mTypes</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.mTypesToRegistryKey" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure we’re dealing with a list of class keys to process
against the registry. Allows us to pass in str ‘MetaRig’ or
r9Meta.MetaRig to the args for type checking</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassDataFromNode">
<code class="descname">getMClassDataFromNode</code><span class="sig-paren">(</span><em>node</em>, <em>checkInstance=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassDataFromNode" title="Permalink to this definition">¶</a></dt>
<dd><p>from the node get the class to instantiate, this gives us a level of
flexibility over mClass attr rather than pure hard coding as it was previously</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – node to retrieve the mClass binding from</li>
<li><strong>checkInstance</strong> – bool, specify whether to test the given node as a per existing instance
this check is purely for speed internally so we don’t check the same thing over and over again</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.registerMClassNodeMapping">
<code class="descname">registerMClassNodeMapping</code><span class="sig-paren">(</span><em>nodeTypes=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.registerMClassNodeMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to allow you to extend the type of nodes included in all the
getMeta searches. Allows you to expand into using nodes of any type
as metaNodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nodeTypes</strong> – allows you to expand metaData and use any nodeType
default is always ‘network’</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this now validates ‘nodeTypes’ against Maya registered nodeTypes before being
allowed into the registry. Why, well lets say you have a new nodeType from a
plugin but that plugin isn’t currently loaded, this now stops that type being
generically added by any custom boot sequence.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.printMetaTypeRegistry">
<code class="descname">printMetaTypeRegistry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.printMetaTypeRegistry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassNodeTypes">
<code class="descname">getMClassNodeTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassNodeTypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic getWrapper for all nodeTypes registered in the Meta_NodeType global</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.resetMClassNodeTypes">
<code class="descname">resetMClassNodeTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.resetMClassNodeTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.generateUUID">
<code class="descname">generateUUID</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.generateUUID" title="Permalink to this definition">¶</a></dt>
<dd><p>unique UUID used by the caching system</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.registerMClassNodeCache">
<code class="descname">registerMClassNodeCache</code><span class="sig-paren">(</span><em>mNode</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.registerMClassNodeCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a given mNode to the global RED9_META_NODECACHE cache of currently instantiated
MetaNode objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mNode</strong> – instantiated mNode to add</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMetaFromCache">
<code class="descname">getMetaFromCache</code><span class="sig-paren">(</span><em>mNode</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMetaFromCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Pull the given mNode from the RED9_META_NODECACHE if it’s
already be instantiated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mNode</strong> – str(name) of node from DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.upgrade_toLatestBindings">
<code class="descname">upgrade_toLatestBindings</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.upgrade_toLatestBindings" title="Permalink to this definition">¶</a></dt>
<dd><p>take a current scene and upgrade all the mNodes to include any new
binding attrs that the base class may have been upgraded to use.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.printMetaCacheRegistry">
<code class="descname">printMetaCacheRegistry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.printMetaCacheRegistry" title="Permalink to this definition">¶</a></dt>
<dd><p>print the current VALID Cache of instantiated MetaNodes
Note that we call a cleanCache before printing to remove any
currently invalid MObjects from the Cache.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.cleanCache">
<code class="descname">cleanCache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.cleanCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Run through the current cache of metaNodes and confirm that they’re
all still valid by testing the MObjectHandles.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.removeFromCache">
<code class="descname">removeFromCache</code><span class="sig-paren">(</span><em>mNodes</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.removeFromCache" title="Permalink to this definition">¶</a></dt>
<dd><p>remove instanciated mNodes from the cache</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.resetCache">
<code class="descname">resetCache</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.resetCache" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the global cache, called after SceneOpen or NewScene</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.resetCacheOnSceneNew">
<code class="descname">resetCacheOnSceneNew</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.resetCacheOnSceneNew" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMClassNodeCache">
<code class="descname">getMClassNodeCache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMClassNodeCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic getWrapper for all nodeTypes registered in the Meta_NodeType global</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMObject">
<code class="descname">getMObject</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMObject" title="Permalink to this definition">¶</a></dt>
<dd><p>base wrapper to get the MObject from node</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.nodeLockManager">
<code class="descname">nodeLockManager</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.nodeLockManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple decorator to manage metaNodes which are locked. Why lock??
Currently just the metaRig and therefore any subclasses of that are locked.
The reason is that the Maya ‘network’ node I use has issues when certain
connections are deleted, the node itself can get deleted and cleanup, removing
the entire network! Try it, make a metaNode and key an attr on it, then run
cutKeys…the node will be deleted.</p>
<p>This decorator is used to manage the unlocking of self for all calls that
require change access rights to the ‘network’ node itself.</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.pymelHandler">
<code class="descname">pymelHandler</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.pymelHandler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.attributeDataType">
<code class="descname">attributeDataType</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.attributeDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the attribute type for all the cmds handling</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.isMetaNode">
<code class="descname">isMetaNode</code><span class="sig-paren">(</span><em>node</em>, <em>mTypes=[]</em>, <em>checkInstance=True</em>, <em>returnMClass=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.isMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple bool, Maya Node is or isn’t an mNode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – Maya node to test</li>
<li><strong>mTypes</strong> – only match given MetaClass’s - str or class accepted</li>
<li><strong>checkInstance</strong> – bool, used only internally for optimisation</li>
<li><strong>returnMClass</strong> – if True return the str(mClass) that this node is bound too</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this does not instantiate the mClass to query it like the
isMetaNodeInherited which has to figure the subclass mapping</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.isMetaNodeInherited">
<code class="descname">isMetaNodeInherited</code><span class="sig-paren">(</span><em>node</em>, <em>mInstances=[]</em>, <em>mode='short'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.isMetaNodeInherited" title="Permalink to this definition">¶</a></dt>
<dd><p>unlike isMetaNode which checks the node against a particular MetaClass,
this expands the check to see if the node is inherited from or a subclass of
a given Meta base class, ie, part of a system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – node we’re wanting to test</li>
<li><strong>mInstances</strong> – list of instances we want to validate against</li>
<li><strong>mode</strong> – ‘short’ or ‘full’ how we determine the inheritance, either full class
inheritance OR from the RED9_META_INHERITANCE_MAP[key] (string)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>this has been modified to bypass the issue of the same subclass being imported
in a different space in the inheritance and breaking the standard issubclass()
testing. This was an issue as r9Pro.metadata_pro for clients is imported via the .r9Co
handlers and can break things.</p>
<p class="last">We now us a new global registry r9Meta.RED9_META_INHERITANCE_MAP which stores
each classes inheritance in long and short form on boot.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.isMetaNodeClassGrp">
<code class="descname">isMetaNodeClassGrp</code><span class="sig-paren">(</span><em>node</em>, <em>mClassGrps=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.isMetaNodeClassGrp" title="Permalink to this definition">¶</a></dt>
<dd><p>check the mClassGrp attr to see if it matches the given</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMetaNodes">
<code class="descname">getMetaNodes</code><span class="sig-paren">(</span><em>mTypes=[]</em>, <em>mInstances=[]</em>, <em>mClassGrps=[]</em>, <em>mAttrs=None</em>, <em>dataType='mClass'</em>, <em>nTypes=None</em>, <em>mSystemRoot=False</em>, <em>byname=[]</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMetaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all mClass nodes in scene and return as mClass objects if possible</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mTypes</strong> – only return meta nodes of a given type</li>
<li><strong>mInstances</strong> – idea - this will check subclass inheritance, ie, MetaRig would
return ALL nodes who’s class is inherited from MetaRig. Allows you to
group the data more efficiently by base classes and their inheritance</li>
<li><strong>mClassGrps</strong> – checks the mClassGrp used to soft grp nodes and mark ones as a certain
system type without looking at class inheritance. Good for marking key classes as bases</li>
<li><strong>mAttrs</strong> – uses the FilterNode.lsSearchAttributes call to match nodes via given attrs</li>
<li><strong>dataType</strong> – default=’mClass’ return the nodes already instantiated to
the correct class object. If not then return the Maya node itself</li>
<li><strong>nTypes</strong> – only inspect nodes of a given Type</li>
<li><strong>byname</strong> – [] a specific list of node names to search for</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMetaRigs">
<code class="descname">getMetaRigs</code><span class="sig-paren">(</span><em>mInstances='MetaRig', mClassGrps=['MetaRig']</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMetaRigs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper over the get call to fire back specifically MetaRigs.
We use mInstances rather than mTypes directly for MetaRig to
cope with people subclassing, then we clamp the search to the Root MetaRig
using the mClassGrps variable. This probably will expand as it’s tested</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Pro_MetaRig_SRC raised in the return stack 24/09/20 
order now goes: ‘Pro_MetaRig’, ‘Pro_MetaRig_FacialUI’, ‘Pro_MetaRig_SRC’, ‘MetaRig’</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getMetaRigs_fromSelected">
<code class="descname">getMetaRigs_fromSelected</code><span class="sig-paren">(</span><em>singular=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getMetaRigs_fromSelected" title="Permalink to this definition">¶</a></dt>
<dd><p>light wrap over the getMetaRigs function to return a list of mRigs connected
to the selected nodes</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getUnregisteredMetaNodes">
<code class="descname">getUnregisteredMetaNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getUnregisteredMetaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspect all nodes for the mClass attrs, then see if those nodes and mClass
types are currently registered in the systems. This means you can inspect
files from others who have bespoke MClass’s and still see their node structures
even though you won’t be able to use or return their class objects</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getConnectedMetaNodes">
<code class="descname">getConnectedMetaNodes</code><span class="sig-paren">(</span><em>nodes</em>, <em>source=True</em>, <em>destination=True</em>, <em>mTypes=[]</em>, <em>mInstances=[]</em>, <em>mAttrs=None</em>, <em>dataType='mClass'</em>, <em>nTypes=None</em>, <em>skipTypes=[]</em>, <em>skipInstances=[]</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getConnectedMetaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>From a given set of Maya Nodes return all connected mNodes
Default return is mClass objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to inspect for connected meta data, note these are cmds MAYA nodes</li>
<li><strong>source</strong> – <cite>bool</cite> clamp the search to the source side of the graph</li>
<li><strong>destination</strong> – <cite>bool</cite> clamp the search to the destination side of the graph</li>
<li><strong>mTypes</strong> – return only given MetaClass’s</li>
<li><strong>mInstances</strong> – this will check subclass inheritance, ie, ‘MetaRig’ would
return ALL nodes who’s class is inherited from MetaRig. Allows you to
group the data more efficiently by base classes and their inheritance</li>
<li><strong>mAttrs</strong> – uses the FilterNode.lsSearchAttributes call to match nodes via given attrs</li>
<li><strong>dataType</strong> – default=’mClass’ return the nodes already instantiated to
the correct class object. If not then return the Maya node</li>
<li><strong>nTypes</strong> – only return nodes of a given type, note this type must be registered to meta!</li>
<li><strong>skipTypes</strong> – if given this is a list of specific mNode types that will be skipped during the
search WITHOUT instantiating their mNodes</li>
<li><strong>skipInstances</strong> – if given this is a list of specific mNode mInstances types that will be skipped during the
search WITHOUT instantiating their mNodes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.getConnectedMetaSystemRoot">
<code class="descname">getConnectedMetaSystemRoot</code><span class="sig-paren">(</span><em>node</em>, <em>mTypes=[]</em>, <em>ignoreTypes=[]</em>, <em>mSystemRoot=True</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.getConnectedMetaSystemRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>From a given node see if it’s part of a MetaData system, if so
walk up the parent tree till you get to top meta node and return the class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ignoreTypes</strong> – if the given mClass node types are found to be systemRoots ignore them
why, lets say we have a system with several mNodes that are technically the head of the
system and you need to skip a given type.</li>
<li><strong>mTypes</strong> – like the rest of Meta, if you give it a specific mType to find as root it will do
just that if that node is a root node in the system.</li>
<li><strong>mSystemRoot</strong> – whether to respect the mSystemRoot abort bool on the nodes, default=True</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this walks upstream only from the given node, so if you effectively have multiple root nodes
in the system but wired to different parts of the network, and when walking upstream from the given
you only get to one of those because of the network wiring, then that is correct.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.convertMClassType">
<code class="descname">convertMClassType</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.convertMClassType" title="Permalink to this definition">¶</a></dt>
<dd><p>change the current mClass type of the given class instance. This used to be
an internal func in eth baseClass but that seemed to make no sense as
you’re mutating the class dynamically</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cls</strong> – initialize mClass object t9o mutate</li>
<li><strong>newMClass</strong> – new class definition for the given cls</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you’re converting a StandardWrapped Maya node to a fully fledged mNode then you also
need to ensure that that NODETYPE is registered to meta or else it won’t get picked up
when you run any of the gets.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.convertNodeToMetaData">
<code class="descname">convertNodeToMetaData</code><span class="sig-paren">(</span><em>nodes</em>, <em>mClass</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.convertNodeToMetaData" title="Permalink to this definition">¶</a></dt>
<dd><p>pass in a node and convert it to a MetaNode, assuming that the nodeType
is valid in the metaNodeTypesRegistry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to cast to mClass instances</li>
<li><strong>mClass</strong> – mClass class to convert them too</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ideally you should use the convertMClassType func now as that wraps this if the
nodes passed in aren’t already instanitated or bound to meta</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.delete_mNode">
<code class="descname">delete_mNode</code><span class="sig-paren">(</span><em>mNode</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.delete_mNode" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to delete a given mNode via the standard mClass call
rather than the mNodes internal class.delete() call to avoid
subclass issues when calling super().delete()</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.createMetaNode">
<code class="descname">createMetaNode</code><span class="sig-paren">(</span><em>mType=None</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.createMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>cheers Josh for this suggestion and code snippet ;)</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MClassNodeUI">
<em class="property">class </em><code class="descname">MClassNodeUI</code><span class="sig-paren">(</span><em>mTypes=None</em>, <em>mInstances=None</em>, <em>mClassGrp=None</em>, <em>closeOnSelect=False</em>, <em>funcOnSelection=None</em>, <em>sortBy='byClass'</em>, <em>allowMulti=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Simple UI to display all MetaNodes in the scene</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mTypes</strong> – MetaNode class to search and display ‘MetaRig’</li>
<li><strong>mInstances</strong> – MetaNode inheritance map, ie show all subclass of mType..</li>
<li><strong>closeOnSelect</strong> – on text select close the UI</li>
<li><strong>funcOnSelection</strong> – function to run where the selected mNode is expected
as first arg, ie funcOnSelection=cmd.select so that when run the item is
selected in the UI cmds.select(item) is run. Basically used as a dynamic callback</li>
<li><strong>sortBy</strong> – Sort the nodes found ‘byClass’ or ‘byName’</li>
<li><strong>allowMulti</strong> – allow multiple selection in the UI</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.show">
<em class="property">classmethod </em><code class="descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.show" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.graphNetwork">
<code class="descname">graphNetwork</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.graphNetwork" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.selectCmd">
<code class="descname">selectCmd</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.selectCmd" title="Permalink to this definition">¶</a></dt>
<dd><p>callback run on select in the UI, allows you to run the func passed
in by the funcOnSelection arg</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.deleteCall">
<code class="descname">deleteCall</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.deleteCall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.doubleClick">
<code class="descname">doubleClick</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.doubleClick" title="Permalink to this definition">¶</a></dt>
<dd><p>run the generic meta.getChildren call and select the results</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.fillScroll">
<code class="descname">fillScroll</code><span class="sig-paren">(</span><em>sortBy=None</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.fillScroll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.printRegisteredNodeTypes">
<code class="descname">printRegisteredNodeTypes</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.printRegisteredNodeTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.printRegisteredMetaClasses">
<code class="descname">printRegisteredMetaClasses</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.printRegisteredMetaClasses" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MClassNodeUI.printMetaNodeCache">
<code class="descname">printMetaNodeCache</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MClassNodeUI.printMetaNodeCache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="Red9.core.Red9_Meta.MetaInstanceError">
<em class="property">exception </em><code class="descname">MetaInstanceError</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaInstanceError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.Exception</span></code></p>
<p>exception thrown if the mClass object instance is no longer valid
usually thrown if the class object is called after the Maya scene has been
changed by loading or new</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaClass">
<em class="property">class </em><code class="descname">MetaClass</code><span class="sig-paren">(</span><em>node=None</em>, <em>name=None</em>, <em>nodeType='network'</em>, <em>autofill='all'</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base Class for Meta support. This manages all the attribute and class
management for all subsequent inherited classes. This is the core of
the MetaData factory API</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – Maya Node - if given we test it for the mClass attribute, if it exists
we initialize a class of that type and return. If not passed in then we
make a new network node for the type given.</li>
<li><strong>name</strong> – only used on create, name to set for the new Maya Node (self.mNode)</li>
<li><strong>nodeType</strong> – allows you to specify a node of type to create as a new mClass node.
default is ‘network’, not that for any node to show up in the get
calls that type MUST be registered in the RED9_META_NODETYPE_REGISTERY</li>
<li><strong>autofill</strong> – ‘str’ cast all the MayaNode attrs into the class dict by default.
Updated: modes: ‘all’ or ‘messageOnly’. all casts every attr, messageOnly
fills the node with just message linked attrs (designed for MetaClass work
with HIK characterNode)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mNode is now a wrap on the MObject so will always be in sync even if the node is renamed/parented</p>
</div>
<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.cached">
<code class="descname">cached</code><em class="property"> = None</em><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.cached" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.UNMANAGED">
<code class="descname">UNMANAGED</code><em class="property"> = ['mNode', 'mNodeID', '_MObject', '_MObjectHandle', '_MFnDependencyNode', '_lockState', 'lockState', '_forceAsMeta', '_lastDagPath', '_lastUUID']</em><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.UNMANAGED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isValid">
<code class="descname">isValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isValid" title="Permalink to this definition">¶</a></dt>
<dd><p>a metaNode in this case is valid if it has connections, if not it’s classed invalid</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isValidMObject">
<code class="descname">isValidMObject</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isValidMObject" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the MObject, without this Maya will crash if the pointer is no longer valid</p>
<p>TODO: thinking of storing the dagPath when we fill in the mNode to start with and
if this test fails, ie the scene has been reloaded, then use the dagPath to refine
and refill the mNode property back in…. maybe??</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isSystemRoot">
<code class="descname">isSystemRoot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isSystemRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>used by the getConnectedMetaSystemRoot call to identify if this
node is a top system node. Having his as an attr allows us to designate
certain subsystems as root nodes in their own right. Ie, Facial controlBoard</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.mNode">
<code class="descname">mNode</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.mNode" title="Permalink to this definition">¶</a></dt>
<dd><p>mNode is the pointer to the Maya object itself, retrieved via the MObject
under the hood so it’s always in sync.</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.mNodeID">
<code class="descname">mNodeID</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.mNodeID" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.mNodeMObject">
<code class="descname">mNodeMObject</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.mNodeMObject" title="Permalink to this definition">¶</a></dt>
<dd><p>exposed wrapper to return the MObject directly, this passes via the MObjectHandle
to ensure that the MObject cached is still valid</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getInheritanceMap">
<code class="descname">getInheritanceMap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getInheritanceMap" title="Permalink to this definition">¶</a></dt>
<dd><p>return the inheritance mapping of this class instance</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.lockState">
<code class="descname">lockState</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.lockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Lockstate is just that, the lockNode state of the Maya node</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.setUUID">
<code class="descname">setUUID</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.setUUID" title="Permalink to this definition">¶</a></dt>
<dd><p>unique UUID used by the caching system</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getUUID">
<code class="descname">getUUID</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getUUID" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.attrType">
<code class="descname">attrType</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.attrType" title="Permalink to this definition">¶</a></dt>
<dd><p>return the api attr type</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.hasAttr">
<code class="descname">hasAttr</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.hasAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrapper check for attrs on the mNode itself.
Note this is not run in some of the core internal calls in this baseClass</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.attrIsLocked">
<code class="descname">attrIsLocked</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.attrIsLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>check the attribute on the mNode to see if it’s locked</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>attr</strong> – attribute to test. Note that this now takes a list and if passed it returns the
overall state, ie, if any of the attrs in the list are locked then it will return True, only
if they’re all unlocked do we return False</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.attrSetLocked">
<code class="descname">attrSetLocked</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.attrSetLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>set the lockState of a given attr on the mNode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> – the attr to lock, this now also takes a list of attrs</li>
<li><strong>state</strong> – lock state</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.attrBreakConnections">
<code class="descname">attrBreakConnections</code><span class="sig-paren">(</span><em>attr</em>, <em>source=True</em>, <em>dest=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.attrBreakConnections" title="Permalink to this definition">¶</a></dt>
<dd><p>break all current connections to the given attr on the mNode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> – the attr to break</li>
<li><strong>source</strong> – True by default, break connections on the source side</li>
<li><strong>dest</strong> – False by default, break connections on the destination side</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.renameAttr">
<code class="descname">renameAttr</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.renameAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>wrap over cmds.renameAttr</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.delAttr">
<code class="descname">delAttr</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.delAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>delete a given attr</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.addAttr">
<code class="descname">addAttr</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.addAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapped version of Maya addAttr that manages the basic type flags for you
whilst also setting the attr on the MayaNode/class object itself.
I now merge in <a href="#id1"><span class="problematic" id="id2">**</span></a>kws to the dict I pass to the add and set commands here so you
can specify all standard cmds.addAttr, setAttr flags in the same call.
ie min, max, l, k, cb</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> – attribute name to add (standard ‘longName’ flag)</li>
<li><strong>value</strong> – initial value to set, if a value is given the attribute type is automatically
determined for you.</li>
<li><strong>attrType</strong> – specify the exact type of attr to add. By default I try and resolve
this for you from the type of value passed in.</li>
<li><strong>hidden</strong> – whether the attr is set available in the channelBox (only applies keyable attrs)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>specific attr management for given types below:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">double3</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;attrName&#39;</span><span class="p">,</span> <span class="n">attrType</span><span class="o">=</span><span class="s1">&#39;double3&#39;</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="n">value2</span><span class="p">,</span><span class="n">value3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">float3</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;attrName&#39;</span><span class="p">,</span> <span class="n">attrType</span><span class="o">=</span><span class="s1">&#39;float3&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="n">value2</span><span class="p">,</span><span class="n">value3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;attrName&#39;</span><span class="p">,</span> <span class="n">attrType</span><span class="o">=</span><span class="s1">&#39;enum&#39;</span><span class="p">,</span>   <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">enumName</span><span class="o">=</span><span class="s1">&#39;Centre:Left:Right&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doubleArray</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;attrName&#39;</span><span class="p">,</span> <span class="n">attrType</span><span class="o">=</span><span class="s1">&#39;doubleArray&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="s1">&#39;jsonDict&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="mf">2.0</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="mf">3.3</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">max values for int is 2,147,483,647 (int32)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.listAttrsOfType">
<code class="descname">listAttrsOfType</code><span class="sig-paren">(</span><em>Type='message'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.listAttrsOfType" title="Permalink to this definition">¶</a></dt>
<dd><p>this is a fast method to list all attrs of type on the mNode</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">listAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mNode</span><span class="p">)</span> <span class="k">if</span> <span class="n">cmds</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mNode</span><span class="p">,</span><span class="n">attr</span><span class="p">),</span><span class="nb">type</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;message&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Simply using the above cmds calls is DOG SLOW upto this which goes via the Api.
TODO: expand the Type support here</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getEnumAttr_as_string">
<code class="descname">getEnumAttr_as_string</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getEnumAttr_as_string" title="Permalink to this definition">¶</a></dt>
<dd><p>from a given enum attr on this mNode, return the current enum value as a string</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.shortName">
<code class="descname">shortName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.shortName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.select" title="Permalink to this definition">¶</a></dt>
<dd><p>args and kws are now passed through into the Maya select call</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.rename">
<code class="descname">rename</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename the mNode itself, again because we get the mNode via the MObject renaming is handled correctly</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> – new name for the mNode</li>
<li><strong>renameChildLinks</strong> – set to False by default, this will rename connections back to the mNode
from children who are connected directly to it, via an attr that matches the current mNode name.
These connected Attrs will be renamed to reflect the change in node name</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete the mNode and this class instance</p>
<p>Note that if you delete a ‘network’ node then by default
Maya will delete connected child nodes unless they’re wired.
To prevent this set the self.lockState=True in your classes __init__</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=0</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>a generic gather function designed to be overloaded at the class level and used to
collect specific information on the given class in a generic way. This is used by the
r9Aninm format in Pro to collect key info on the system being saved against</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>level</strong> – added here for the more robust checking that the rigging systems need</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.gatherInfo_mNode">
<code class="descname">gatherInfo_mNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.gatherInfo_mNode" title="Permalink to this definition">¶</a></dt>
<dd><p>this is now split like this because some times, when sub-classing, we still want to get
back to this very low level gather call. In ProPack we overload gatherInfo() repeatedly
but in certain instances, we still want to return just this base info for the mNode.
This now keeps the info here very dynamic for all child classes no matter how deep they are!</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaClass.userinfo">
<code class="descname">userinfo</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.userinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>a simple node descriptor so that sub-classes can have tracking or just user info blocks that
animators can use as notation</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isReferenced">
<code class="descname">isReferenced</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isReferenced" title="Permalink to this definition">¶</a></dt>
<dd><p>is node.mNode referenced?</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.referenceNode">
<code class="descname">referenceNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.referenceNode" title="Permalink to this definition">¶</a></dt>
<dd><p>if referenced return the referenceNode itself</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.referencePath">
<code class="descname">referencePath</code><span class="sig-paren">(</span><em>wcn=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.referencePath" title="Permalink to this definition">¶</a></dt>
<dd><p>if referenced return the referenced filepath</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.referenceGroup">
<code class="descname">referenceGroup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.referenceGroup" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">string name of reference group</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.nameSpace">
<code class="descname">nameSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.nameSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag has been modified to return just the direct namespace
of the node, not all nested namespaces if found. Now returns a string</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.nameSpaceFull">
<code class="descname">nameSpaceFull</code><span class="sig-paren">(</span><em>asList=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.nameSpaceFull" title="Permalink to this definition">¶</a></dt>
<dd><p>the namespace call has been modified to only return the single
direct namespace of a node, not the nested. This new func will
return the namespace in it’s entirity either as a list or a
catenated string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>asList</strong> – either return the namespaces in a list or as a catenated string (default)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.isChildNode">
<code class="descname">isChildNode</code><span class="sig-paren">(</span><em>node</em>, <em>attr=None</em>, <em>srcAttr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.isChildNode" title="Permalink to this definition">¶</a></dt>
<dd><p>test if a node is already connected to the mNode via a given attr link.
Why the wrap? well this gets over the issue of array index’s in the connections</p>
<p>cmds.isConnected(‘node.attr[0]’,’other.attr[0]’)
fails if simply asked:
cmds.isConnected(‘node.attr’,other.attr’)</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.connectChildren">
<code class="descname">connectChildren</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.connectChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast method of connecting multiple nodes to the mNode via a message attr link.
This call generates a MULTI message on both sides of the connection and is designed
for more complex parent child relationships</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – Maya nodes to connect to this mNode</li>
<li><strong>attr</strong> – Name for the message attribute</li>
<li><strong>srcAttr</strong> – if given this becomes the attr on the child node which connects it
to self.mNode. If NOT given this attr is set to self.mNodeID</li>
<li><strong>cleanCurrent</strong> – Disconnect and clean any currently connected nodes to this attr.
Note this is operating on the mNode side of the connection, removing
any currently connected nodes to this attr prior to making the new ones</li>
<li><strong>force</strong> – Maya’s default connectAttr ‘force’ flag, if the srcAttr is already connected
to another node force the connection to the new attr</li>
<li><strong>allowIncest</strong> – Over-ride the default behaviour when dealing with child nodes that are
standard Maya Nodes not metaNodes. Default in this case is to NOT index manage
the plugs, this flag overloads that, allow multiple parents.</li>
<li><strong>srcSimple</strong> – By default when we wire children we expect arrays so both plugs on the src and dest
side of the connection are index managed. This flag stops the index and uses a single simple wire on the
srcAttr side of the plug ( the child )</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: check the attr type, if attr exists and is a non-multi message then don’t run the indexBlock</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.connectChild">
<code class="descname">connectChild</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.connectChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast method of connecting a node to the mNode via a message attr link. This call
generates a NONE-MULTI message on both sides of the connection and is designed
for simple parent child relationships.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this call by default manages the attr to only ONE CHILD to avoid this use cleanCurrent=False</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – Maya node to connect to this mNode</li>
<li><strong>attr</strong> – Name for the message attribute</li>
<li><strong>srcAttr</strong> – If given this becomes the attr on the child node which connects it
to self.mNode. If NOT given this attr is set to self.mNodeID</li>
<li><strong>cleanCurrent</strong> – Disconnect and clean any currently connected nodes to the attr on self.
Note this is operating on the mNode side of the connection, removing
any currently connected nodes to this attr prior to making the new ones</li>
<li><strong>force</strong> – Maya’s default connectAttr ‘force’ flag, if the srcAttr is already connected
to another node force the connection to the new attr</li>
<li><strong>allow_multi</strong> – allows the same node to connect back to this mNode under multiple wires
default behaviour is to only let a single wire from an mNode to a child</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: do we move the cleanCurrent to the end so that if the connect fails you’re not left
with a half run setup?</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.connectParent">
<code class="descname">connectParent</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.connectParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast method of connecting message links to the mNode as parents</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – Maya nodes to connect to this mNode</li>
<li><strong>attr</strong> – Name for the message attribute on the PARENT!</li>
<li><strong>srcAttr</strong> – If given this becomes the attr on the node which connects it
to the parent. If NOT given this attr is set to parents shortName</li>
<li><strong>cleanCurrent</strong> – Exposed from the connectChild code which is basically what this is running in reverse</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: Modify so if a metaClass is passed in use it’s addAttr cmd so the new
attr is registered in the class given</p>
<p>TODO: Manage connection Index like the connectChildren call does?</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.disconnectChild">
<code class="descname">disconnectChild</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.disconnectChild" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect a given child node from the mNode. Default is to remove
the connection attribute in the process, cleaning up both sides of
the connection. Note that the attrs only get removed if nothing
else is connected to it, ie, it’s safe to do so.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – the Maya node to disconnect from the mNode</li>
<li><strong>deleteSourcePlug</strong> – if True delete SOURCE side attribiute after disconnection
but ONLY if it’s no longer connected to anything else.</li>
<li><strong>deleteDestPlug</strong> – if True delete the DESTINATION side attribiute after disconnection
but ONLY if it’s no longer connected to anything else.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#testCode:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span>  <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">MetaClass</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;master&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master2</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">MetaClass</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;master2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child1</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">MetaClass</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;child1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child2</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">MetaClass</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;child2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span><span class="o">=</span><span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">polyCube</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span><span class="n">l</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span><span class="o">.</span><span class="n">connectChildren</span><span class="p">([</span><span class="n">child1</span><span class="p">,</span><span class="n">child2</span><span class="p">,</span><span class="n">cube</span><span class="p">],</span><span class="s1">&#39;modules&#39;</span><span class="p">,</span><span class="s1">&#39;puppet&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master2</span><span class="o">.</span><span class="n">connectChildren</span><span class="p">([</span><span class="n">child1</span><span class="o">.</span><span class="n">mNode</span><span class="p">,</span><span class="n">child2</span><span class="o">.</span><span class="n">mNode</span><span class="p">,</span><span class="n">cube</span><span class="p">],</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="s1">&#39;master&#39;</span><span class="p">,</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span><span class="o">.</span><span class="n">connectChildren</span><span class="p">([</span><span class="n">child1</span><span class="p">,</span><span class="n">child2</span><span class="p">],</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="s1">&#39;master&#39;</span><span class="p">,</span><span class="n">cleanCurrent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span><span class="o">.</span><span class="n">disconnectChild</span><span class="p">(</span><span class="n">child2</span><span class="p">,</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">master</span><span class="o">.</span><span class="n">disconnectChild</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.addChildMetaNode">
<code class="descname">addChildMetaNode</code><span class="sig-paren">(</span><em>mClass</em>, <em>attr</em>, <em>srcAttr=None</em>, <em>nodeName=None</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.addChildMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic call to add a MetaNode as a Child of self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mClass</strong> – mClass to generate, given as a valid key to the
RED9_META_REGISTERY ie ‘MetaRig’ OR a class object, ie r9Meta.MetaRig</li>
<li><strong>attr</strong> – message attribute to wire the new node too</li>
<li><strong>name</strong> – optional name to give the new name</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getChildMetaNodes">
<code class="descname">getChildMetaNodes</code><span class="sig-paren">(</span><em>walk=False</em>, <em>mAttrs=None</em>, <em>stepover=False</em>, <em>currentSystem=False</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getChildMetaNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Find any connected Child MetaNodes to this mNode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk</strong> – walk the connected network and return ALL children connected in the tree</li>
<li><strong>mAttrs</strong> – only return connected nodes that pass the given attribute filter</li>
<li><strong>stepover</strong> – if you’re passing in ‘mTypes’ or ‘mInstances’ flags then this dictates if
we continue to walk down a tree if it’s parent didn’t match the given type, default is False
which will abort a tree who’s parent didn’t match. With stepover=True we simply stepover
that node and continue down all child nodes</li>
<li><strong>currentSystem</strong> – if True we check for the mSystemRoot attr (bool) on mNodes and if set, we skip
the node and all childnodes from that node. Why?? The mSystsmRoot attr is a marker to denote the
root of a given mRig system, by respecting this we clamp searches to the current system and prevent
walking into the connected child sub-system. Primarily used in ProPack to stop facial nodes being
returned and processed as part of the connected body rig.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mAttrs is only searching attrs on the mNodes themselves, not all children
and although there is no mTypes flag, you can use mAttrs to get childnodes of type
by going getChildMetaNodes(mAttrs=’mClass=MetaRig’)</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the <a href="#id3"><span class="problematic" id="id4">**</span></a>kws are passed directly to the getConnectedMetaNodes func, it will
also take ALL of that functions <a href="#id5"><span class="problematic" id="id6">**</span></a>kws functionality in the initial search:
mTypes=[], mInstances=[], mAttrs=None, dataType=’mClass’, skipTypes=[], skipInstances=[]</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getChildSystemRoots">
<code class="descname">getChildSystemRoots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getChildSystemRoots" title="Permalink to this definition">¶</a></dt>
<dd><p>return all child MetaNodes that have the mSystemRoot checkbox set. This is used to denote a child
MSystem in it’s own right. Usually used in ProPack to denote a new child MetaRig, ie, facial system
connected as a child of a mRig body system</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getParentMetaNode">
<code class="descname">getParentMetaNode</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getParentMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Find any connected Parent MetaNode to this mNode</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the <a href="#id7"><span class="problematic" id="id8">**</span></a>kws are passed directly to the getConnectedMetaNods func, it will
also take ALL of that functions kws if passed as a kws dict
mTypes=[], mInstances=[], mAttrs=None, dataType=’mClass’, nTypes=None, skipTypes=[], skipInstances=[]</p>
</div>
<p>TODO: implement a walk here to go upstream</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getChildren">
<code class="descname">getChildren</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>This finds all UserDefined attrs of type message and returns all connected nodes
This is now being run in the MetaUI on doubleClick. This is a generic call, implemented
and over-loaded on a case by case basis. At the moment the MetaRig class simple calls
mRig.getRigCtrls() in the call, but it means that we don’t call .mRig.getRigCtrls()
in generic meta functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk</strong> – walk all subMeta connections and include all their children too</li>
<li><strong>mAttrs</strong> – only search connected mNodes that pass the given attribute filter (attr is at the metaSystems level)</li>
<li><strong>cAttrs</strong> – only pass connected children whos connection to the mNode matches the given attr (accepts wildcards)</li>
<li><strong>nAttrs</strong> – [] search returned MayaNodes for given set of attrs and only return matched nodes</li>
<li><strong>asMeta</strong> – return instantiated mNodes regardless of type</li>
<li><strong>asMap</strong> – return the data as a map such that {mNode.plugAttr:[nodes], mNode.plugAttr:[nodes]}</li>
<li><strong>plugsOnly</strong> – only with asMap flag, this truncates the return to [plugAttr, [nodes]]</li>
<li><strong>skip_cAttrs</strong> – if given these cAttrs will be ignored in the returned data</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mAttrs is only searching attrs on the mNodes themselves, not the children. 
cAttrs is searching the connection attr names from the mNodes, uses the cmds.listAttr ‘st’ flag</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the <a href="#id9"><span class="problematic" id="id10">**</span></a>kws are passed directly to the getConnectedMetaNodes func via the getChildMetaNodes call,
it will also take ALL of that functions <a href="#id11"><span class="problematic" id="id12">**</span></a>kws functionality in the initial search:
mTypes=[], mInstances=[], mAttrs=None, dataType=’mClass’, skipTypes=[], skipInstances=[]</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_Meta.MetaClass.getNodeConnectionMetaDataMap">
<em class="property">static </em><code class="descname">getNodeConnectionMetaDataMap</code><span class="sig-paren">(</span><em>node</em>, <em>mTypes=[]</em>, <em>mNodes=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getNodeConnectionMetaDataMap" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a generic wrapper to extract metaData connection info for any given node
used currently to build the pose dict up, and compare / match the data on load.
In the base implementation this gives you a dict of mNodeID and attr which the nodes is connected too.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> – node to inspect and get the connection data back from</li>
<li><strong>mTypes</strong> – if given this is a list of specific mTypes that the connected mNode must be</li>
<li><strong>mNodes</strong> – if given this is a list of specific mNodes themselves that we clamp the return too. This allows us to
clamp the return to a specific mRig system IF we need a controller wired to multiple mRig systems, such as weapons</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">mNode_data={} which is directly pushed into the PoseFile under the [metaData] key</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is designed to be overloaded so you can craft your own metaData block in the
poseFiles, allows you to craft the data you want to store against a node.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getNodeConnetionAttr">
<code class="descname">getNodeConnetionAttr</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getNodeConnetionAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>really light wrapper, designed to return the attr via which a node
is connected to this metaNode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> – node to test connection attr for</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This will be depricated soon and replaced by getNodeConnections which is
more flexible as it returns and filters all plugs between self and the given node.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaClass.getNodeConnections">
<code class="descname">getNodeConnections</code><span class="sig-paren">(</span><em>node</em>, <em>filters=[]</em>, <em>bothplugs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaClass.getNodeConnections" title="Permalink to this definition">¶</a></dt>
<dd><p>really light wrapper, designed to return all connections
between a given node and the mNode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – node to test connection attr for</li>
<li><strong>filters</strong> – filter string to match for the returns</li>
<li><strong>bothplugs</strong> – if True we return a list of tuples</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.deleteEntireMetaRigStructure">
<code class="descname">deleteEntireMetaRigStructure</code><span class="sig-paren">(</span><em>searchNode=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.deleteEntireMetaRigStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a hard core unplug and cleanup of all attrs added by the
MetaRig, all connections and all nodes. Use CAREFULLY!</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaRig">
<em class="property">class </em><code class="descname">MetaRig</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>Sub-class of Meta used as the back-bone of our internal rigging
systems. This is the core of how we hook all our tools to meta
in a seemless manner and bind some core functionality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> – name of the node and in this case, the RigSystem itself</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=0</em>, <em>encode_objects=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>gather key info on this system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>encode_objects</strong> – if True we should encode / stringify all objects for safe json conversion</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.isValid">
<code class="descname">isValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.isValid" title="Permalink to this definition">¶</a></dt>
<dd><p>simple check to see if this definition is still valid and wired to
controllers and not just to empty subSystems as is the case if you
were to delete all the dag nodes in a rig, leaving the MetaRig
structure in-tact but useless</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>full=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>full delete and clean of a rig system and network</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.ctrl_main">
<code class="descname">ctrl_main</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.ctrl_main" title="Permalink to this definition">¶</a></dt>
<dd><p>why wrap, because when we subclass, IF we’ve modified the CRTL_Prefix then we
can’t rely on the default CTRL_Main[0] wire, so we wrap it with the current
instances self.CTRL_Prefix</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.ctrl_offset">
<code class="descname">ctrl_offset</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.ctrl_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>why wrap, because when we subclass, IF we’ve modified the CRTL_Prefix then we
can’t rely on the default CTRL_Offset[0] wire, so we wrap it with the current
instances self.CTRL_Prefix</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this new Offset controller is treated as a root in all of the tools, so if the “incRoot” 
flag is off in the anim tools then this node will also be ignored along with the ctrl_main</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.ctrl_locomotion">
<code class="descname">ctrl_locomotion</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.ctrl_locomotion" title="Permalink to this definition">¶</a></dt>
<dd><p>why wrap, because when we subclass, IF we’ve modified the CRTL_Prefix then we
can’t rely on the default CTRL_LocomotionRoot[0] wire, so we wrap it with the current
instances self.CTRL_Prefix</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">LocomotionRoot is a controller designated as the “locomotion root” node, for games this
generally is the characters global motion pushed to a controller which directly controls
the skeleton root / reference joint</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.characterSet">
<code class="descname">characterSet</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.characterSet" title="Permalink to this definition">¶</a></dt>
<dd><p>return the first connected characterSet found to children</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addGenericCtrls">
<code class="descname">addGenericCtrls</code><span class="sig-paren">(</span><em>nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addGenericCtrls" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass in a list of objects to become generic, non specific
controllers for a given setup. These are all connected to the same slot
so don’t have the search capability that the funct below gives</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addRigCtrl">
<code class="descname">addRigCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>ctrType=None</em>, <em>mirrorData=None</em>, <em>boundData=None</em>, <em>namereplace=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addRigCtrl" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single CTRL of managed type as a child of this mRig.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – Maya node to add</li>
<li><strong>ctrType</strong> – Attr name to assign this too, if not given we take the short nodename</li>
<li><strong>mirrorData</strong> – {side:’Left’, slot:int, axis:’translateX,rotateY,rotateZ’..}</li>
<li><strong>boundData</strong> – {} any additional attrData, set on the given node as attrs</li>
<li><strong>namereplace</strong> – [] if given we apply node.replace(namereplace[0], namereplace[1]) before making the wire</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last line-block">
<div class="line">mirrorData[slot] must NOT == 0 as it’ll be handled as not set by the core.</div>
<div class="line">ctrType &gt;&gt; ‘Main’ is the equivalent of the RootNode in the FilterNode calls.</div>
</div>
</div>
<p>TODO: allow the mirror block to include an offset so that if you need to inverse AND offset
by 180 to get left and right working you can still do so.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getRigCtrls">
<code class="descname">getRigCtrls</code><span class="sig-paren">(</span><em>walk=False</em>, <em>mAttrs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getRigCtrls" title="Permalink to this definition">¶</a></dt>
<dd><p>Depricated Code - use getChildren call now</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getChildren">
<code class="descname">getChildren</code><span class="sig-paren">(</span><em>walk=True</em>, <em>mAttrs=None</em>, <em>cAttrs=[]</em>, <em>nAttrs=[]</em>, <em>asMeta=False</em>, <em>asMap=False</em>, <em>plugsOnly=False</em>, <em>incFacial=False</em>, <em>baseBehaviour=False</em>, <em>skip_cAttrs=[]</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Massively important bit of code, this is used by most bits of code
to find the child controllers linked to this metaRig instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk</strong> – walk all subMeta connections and include all their children too</li>
<li><strong>mAttrs</strong> – only search connected mNodes that pass the given attribute filter (attr is at the metaSystems level)</li>
<li><strong>cAttrs</strong> – only pass connected children whos connection to the mNode matches the given attr (accepts wildcards)</li>
<li><strong>nAttrs</strong> – search returned MayaNodes for given set of attrs and only return matched nodes</li>
<li><strong>asMeta</strong> – return instantiated mNodes regardless of type</li>
<li><strong>asMap</strong> – return the data as a map such that {mNode.plugAttr:[nodes], mNode.plugAttr:[nodes]}</li>
<li><strong>plugsOnly</strong> – only with asMap flag, this truncates the return to {plugAttr:[nodes]}</li>
<li><strong>incFacial</strong> – if we have a facial system linked include it’s children in the return (uses the getFacialSystem to id the facial node)</li>
<li><strong>baseBehaviour</strong> – if True we revert the CTRL_Prefix logic such that the return won’t be clamped to just controllers</li>
<li><strong>skip_cAttrs</strong> – if given these connection attrs will be ignored in the returned data</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">MetaRig getChildren has overloads adding the CTRL_Prefix to the cAttrs so that
the return is just the controllers in the rig. It also now has additional logic
to add any FacialCore system children by adding it’s internal CTRL_Prefix to the list</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the <a href="#id13"><span class="problematic" id="id14">**</span></a>kws are passed directly to the getConnectedMetaNodes func via the getChildMetaNodes call,
it will also take ALL of that functions <a href="#id15"><span class="problematic" id="id16">**</span></a>kws functionality in the initial search:
source=True, destination=True, mTypes=[], mInstances=[], mAttrs=None, dataType=’mClass’, skipTypes=[], skipInstances=[]</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.selectChildren">
<code class="descname">selectChildren</code><span class="sig-paren">(</span><em>walk=True</em>, <em>mAttrs=None</em>, <em>cAttrs=[]</em>, <em>nAttrs=[]</em>, <em>add=False</em>, <em>incFacial=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.selectChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>light wrap over the getChildren so we can more carefully manage it in some of the pro proc bindings</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk</strong> – walk all subMeta connections and include all their children too</li>
<li><strong>mAttrs</strong> – only search connected mNodes that pass the given attribute filter (attr is at the metaSystems level)</li>
<li><strong>cAttrs</strong> – only pass connected children whos connection to the mNode matches the given attr (accepts wildcards)</li>
<li><strong>nAttrs</strong> – search returned MayaNodes for given set of attrs and only return matched nodes</li>
<li><strong>add</strong> – if True add to the current selection (also works with the “shift” modifier</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the wrapper also accepts the ‘Shift’ modifier key, if pressed when this is called then we set the selection to ‘add’
else it’s a fresh selection thats made</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getSkeletonRoots">
<code class="descname">getSkeletonRoots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getSkeletonRoots" title="Permalink to this definition">¶</a></dt>
<dd><p>get the Skeleton Root, used in the poseSaver. By default this looks
for a message link via the attr “exportSkeletonRoot” to the skeletons root jnt
always returns a list!</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getFacialSystem">
<code class="descname">getFacialSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getFacialSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>if we have a FacialCore node return it. This allows you to modify how
you wire up your facial system to metaData but gives us a consistent hook</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addWristCtrl">
<code class="descname">addWristCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addWristCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addElbowCtrl">
<code class="descname">addElbowCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addElbowCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addClavCtrl">
<code class="descname">addClavCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addClavCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addFootCtrl">
<code class="descname">addFootCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addFootCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addKneeCtrl">
<code class="descname">addKneeCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addKneeCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addPropCtrl">
<code class="descname">addPropCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addPropCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addMainCtrl">
<code class="descname">addMainCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addMainCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addRootCtrl">
<code class="descname">addRootCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addRootCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addHipCtrl">
<code class="descname">addHipCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addHipCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addChestCtrl">
<code class="descname">addChestCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side='Cent re'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addChestCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addHeadCtrl">
<code class="descname">addHeadCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addHeadCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addNeckCtrl">
<code class="descname">addNeckCtrl</code><span class="sig-paren">(</span><em>node</em>, <em>side='Centre'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addNeckCtrl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addSupportMetaNode">
<code class="descname">addSupportMetaNode</code><span class="sig-paren">(</span><em>attr</em>, <em>nodeName=None</em>, <em>mClass='MetaRigSupport'</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addSupportMetaNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Not sure the best way to do this, but was thinking that the main mRig
node should be able to have sub MetaClass nodes to cleanly define
what nodes are AnimCtrls, and what nodes you want to tag as Support
subsystems, ie, ikSolvers and construction nodes within the rig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> – Attribute used in the message link. Note this is what you use
to transerve the Dag tree so use something sensible!</li>
<li><strong>nodeName</strong> – Name of the MetaClass network node created</li>
<li><strong>mClass</strong> – the class to be used for the support node - ‘MetaRigSupport’ by default</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addSupportNode">
<code class="descname">addSupportNode</code><span class="sig-paren">(</span><em>node</em>, <em>attr</em>, <em>boundData=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addSupportNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single MAYA node flagged as a SUPPORT node of managed type
Really in the MetaRig design these should be wired to a MetaRigSupport node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – Maya node to add</li>
<li><strong>attr</strong> – Attr name to assign this too</li>
<li><strong>boundData</strong> – {} Data to set on the given node as attrs</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.addMetaSubSystem">
<code class="descname">addMetaSubSystem</code><span class="sig-paren">(</span><em>systemType</em>, <em>side</em>, <em>attr=None</em>, <em>nodeName=None</em>, <em>mClass='MetaRigSubSystem'</em>, <em>buildflags={}</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.addMetaSubSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic design of a MetaRig is that you have sub-systems hanging off an mRig
node, managing all controllers and data for a particular system, such as an
Arm system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>systemType</strong> – Attribute used in the message link. Note this is what you use
to traverse the Dag tree so use something sensible!</li>
<li><strong>side</strong> – Side to designate the system. This is an enum: Centre,Left,Right</li>
<li><strong>attr</strong> – wire name to use in the connections, if not given wire will be side[0]_systemType_’System’</li>
<li><strong>nodeName</strong> – Name of the MetaClass network node created</li>
<li><strong>mClass</strong> – the class to be used for the support node - ‘MetaRigSubSystem’ by default</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMetaSubSystems">
<code class="descname">getMetaSubSystems</code><span class="sig-paren">(</span><em>walk=True</em>, <em>mAttrs=None</em>, <em>stepover=False</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMetaSubSystems" title="Permalink to this definition">¶</a></dt>
<dd><p>return all child MetaSubSystem nodes wired as to this rig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk</strong> – walk the connected network and return ALL children connected in the tree</li>
<li><strong>mAttrs</strong> – only return connected nodes that pass the given attribute filter</li>
<li><strong>stepover</strong> – if you’re passing in ‘mTypes’ or ‘mInstances’ flags then this dictates if
we continue to walk down a tree if it’s parent didn’t match the given type, default is False
which will abort a tree who’s parent didn’t match. With stepover=True we simply stepover
that node and continue down all child nodes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.set_ctrlColour">
<code class="descname">set_ctrlColour</code><span class="sig-paren">(</span><em>colourIndex=4</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.set_ctrlColour" title="Permalink to this definition">¶</a></dt>
<dd><p>set the override colour of a given nodes shapes</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirrorData">
<code class="descname">getMirrorData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirrorData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the MirrorObject to this instance of MetaRig.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">you must run this binding function before using any of
the inbuilt mirror functions</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadMirrorDataMap">
<code class="descname">loadMirrorDataMap</code><span class="sig-paren">(</span><em>mirrorMap</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadMirrorDataMap" title="Permalink to this definition">¶</a></dt>
<dd><p>load a mirror setup onto this rig from a stored mirrorMap file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mirrorMap</strong> – mirror file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.saveMirrorDataMap">
<code class="descname">saveMirrorDataMap</code><span class="sig-paren">(</span><em>filepath</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.saveMirrorDataMap" title="Permalink to this definition">¶</a></dt>
<dd><p>save the current mirror setup for this rig to file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filepath</strong> – filepath to store the mirrorMap too</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirror_opposites">
<code class="descname">getMirror_opposites</code><span class="sig-paren">(</span><em>nodes</em>, <em>forceRefresh=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirror_opposites" title="Permalink to this definition">¶</a></dt>
<dd><p>from the given nodes return a map of the opposite pairs of controllers
so if you pass in a right controller of mirrorIndex 4 you get back the
left[4] mirror node and visa versa. Centre controllers pass straight through</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to get the opposites from</li>
<li><strong>forceRefresh</strong> – forces the mirrorDic (which is cached) to be updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirror_ctrlSets">
<code class="descname">getMirror_ctrlSets</code><span class="sig-paren">(</span><em>set='Centre'</em>, <em>forceRefresh=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirror_ctrlSets" title="Permalink to this definition">¶</a></dt>
<dd><p>from the metaNode grab all controllers and return sets of nodes
based on their mirror side data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>set</strong> – which set/side to get, valid = ‘Left’ ,’Right’, ‘Centre’</li>
<li><strong>forceRefresh</strong> – forces the mirrorDic (which is cached) to be updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirror_lastIndexes">
<code class="descname">getMirror_lastIndexes</code><span class="sig-paren">(</span><em>side</em>, <em>forceRefresh=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirror_lastIndexes" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last mirror index for a given side</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>side</strong> – side to check, valid = ‘Left’ ,’Right’, ‘Centre’</li>
<li><strong>forceRefresh</strong> – forces the mirrorDic (which is cached) to be updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getMirror_nextSlot">
<code class="descname">getMirror_nextSlot</code><span class="sig-paren">(</span><em>side</em>, <em>forceRefresh=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getMirror_nextSlot" title="Permalink to this definition">¶</a></dt>
<dd><p>return the next available slot in the mirrorIndex list for a given side</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>side</strong> – side to check, valid = ‘Left’ ,’Right’, ‘Centre’</li>
<li><strong>forceRefresh</strong> – forces the mirrorDic (which is cached) to be updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>mode='Anim'</em>, <em>hierarchy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>direct mapper call to the Mirror functions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to mirror, if None then we process the entire rig</li>
<li><strong>mode</strong> – either ‘Anim’ or ‘Pose’</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.symmetry">
<code class="descname">symmetry</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>mode='Anim'</em>, <em>hierarchy=True</em>, <em>side='L'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>direct mapper call to the Mirror functions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to mirror, if None then we process the entire rig</li>
<li><strong>mode</strong> – either ‘Anim’ or ‘Pose’</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.mirror_delete_all_markers">
<code class="descname">mirror_delete_all_markers</code><span class="sig-paren">(</span><em>nodes=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.mirror_delete_all_markers" title="Permalink to this definition">¶</a></dt>
<dd><p>delete all mirror markers from the rig</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.poseClipboard_valid">
<code class="descname">poseClipboard_valid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.poseClipboard_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>check the OS Clipboard for a compatible poseCache object. This is used to verify
where the poseCache being loaded comes from. Case in point, you use the Pose - Cache current
command in the dag menus in ProPack. The cache is now pushed to the clipboard in the OS. IF
between caching it and loading it you went into notepad and copied some text then that poseCache
is no longer valid. This returns the state, if it’s usable data or not</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.poseCacheStore">
<code class="descname">poseCacheStore</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.poseCacheStore" title="Permalink to this definition">¶</a></dt>
<dd><p>intended as a cached pose for this mRig, if an attr is given then
the cached pose is stored internally on the node so it can be loaded
back from the mNode internally. If not given then the pose is cached
on this object instance only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> – optional - attr to store the cached pose to</li>
<li><strong>filepath</strong> – optional - path to store the pose too</li>
<li><strong>incRoots</strong> – passed directly to the filterSettings object in the pose, do we process self.ctrl_main?</li>
<li><strong>storeThumbnail</strong> – do we save the thumbnail out or not?</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.poseCacheLoad">
<code class="descname">poseCacheLoad</code><span class="sig-paren">(</span><em>nodes=None</em>, <em>attr=None</em>, <em>filepath=None</em>, <em>incRoots=True</em>, <em>relativePose=False</em>, <em>relativeRots='projected'</em>, <em>relativeTrans='projected'</em>, <em>maintainSpaces=False</em>, <em>skipAttrs=[]</em>, <em>from_clipboard=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.poseCacheLoad" title="Permalink to this definition">¶</a></dt>
<dd><p>load a cached pose back to this mRig. If attr is given then its assumed
that that attr is a cached poseDict on the mNode. If not given then it
will load the cached pose from this objects instance, if there is one stored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – if given load only the cached pose to the given nodes</li>
<li><strong>attr</strong> – optional - attr in which a pose has been stored internally on the mRig</li>
<li><strong>filepath</strong> – optional - posefile to load back</li>
<li><strong>incRoots</strong> – passed directly to the filterSettings object in the pose, do we process self.ctrl_main?</li>
<li><strong>relativePose</strong> – kick in the posePointCloud to align the loaded pose
relatively to the selected node.</li>
<li><strong>relativeRots</strong> – ‘projected’ or ‘absolute’ - how to calculate the offset.</li>
<li><strong>relativeTrans</strong> – ‘projected’ or ‘absolute’ - how to calculate the offset.</li>
<li><strong>maintainSpaces</strong> – this preserves any parentSwitching mismatches between
the stored pose and the current rig settings, current spaces are maintained.
This only checks those nodes in the snapList and only runs under relative mode.</li>
<li><strong>skipAttrs</strong> – attrs to skip when loading the data</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.poseCompare">
<code class="descname">poseCompare</code><span class="sig-paren">(</span><em>poseFile</em>, <em>supressWarning=False</em>, <em>compareDict='skeletonDict'</em>, <em>filterMap=[]</em>, <em>ignoreBlocks=[]</em>, <em>ignoreStrings=[]</em>, <em>ignoreAttrs=[]</em>, <em>longName=False</em>, <em>angularTolerance=0.1</em>, <em>linearTolerance=0.01</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.poseCompare" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrated poseCompare, this checks the mRigs current pose against
a given poseFile. This checks against the ‘skeletonDict’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>poseFile</strong> – given .pose file with valid skeletonDict block</li>
<li><strong>supressWarning</strong> – if False raise the confirmDialogue</li>
<li><strong>angularTolerance</strong> – the tolerance used to check rotate attr float values</li>
<li><strong>linearTolerance</strong> – the tolerance used to check all other float attrs</li>
<li><strong>compareDict</strong> – the internal main dict in the pose file to compare the data with : base options : ‘poseDict’, ‘skeletonDict’</li>
<li><strong>filterMap</strong> – if given this is used as a high level filter, only matching nodes get compared
others get skipped. Good for passing in a master core skeleton to test whilst ignoring extra nodes</li>
<li><strong>ignoreBlocks</strong> – allows the given failure blocks to be ignored. We mainly use this for [‘missingKeys’]</li>
<li><strong>ignoreStrings</strong> – allows you to pass in a list of strings, if any of the keys in the data contain
that string it will be skipped, note this is a partial match so you can pass in wildcard searches [‘_’,’_end’]</li>
<li><strong>ignoreAttrs</strong> – allows you to skip given attrs from the poseCompare calls</li>
<li><strong>longName</strong> – compare the longName DAG path stored against each node, note that the compare strips out any namespaces before compare</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">returns a ‘PoseCompare’ class object with all the compare data in it</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.nodeVisibility">
<code class="descname">nodeVisibility</code><span class="sig-paren">(</span><em>state</em>, <em>skip=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.nodeVisibility" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrapper to hide all ctrls in the rig via their shapeNodes.lodVisibility
so it doesn’t interfer with any display layers etc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> – bool to pass to the lodVisibility attr</li>
<li><strong>skip</strong> – [] child attrs on the mNode to skip during the process allowing certain controllers not to be effected</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.hideNodes">
<code class="descname">hideNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.hideNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>wrap over the nodeVisibility to set False for all Controllers
with the exception of the Main_Ctrl</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.unHideNodes">
<code class="descname">unHideNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.unHideNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>wrap over the nodeVisibility to set True for all Controllers
with the exception of the Main_Ctrl</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.saveAttrMap">
<code class="descname">saveAttrMap</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.saveAttrMap" title="Permalink to this definition">¶</a></dt>
<dd><p>store AttrMap to the metaRig, saving the chBox state of ALL attrs for ALL nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadAttrMap">
<code class="descname">loadAttrMap</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadAttrMap" title="Permalink to this definition">¶</a></dt>
<dd><p>load AttrMap from the metaRig, returning the chBox state of ALL attrs for ALL nodes in the hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.saveZeroPose">
<code class="descname">saveZeroPose</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.saveZeroPose" title="Permalink to this definition">¶</a></dt>
<dd><p>serialize the r9Pose file to the node itself</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadZeroPose">
<code class="descname">loadZeroPose</code><span class="sig-paren">(</span><em>nodes=None</em>, <em>skipAttrs=[]</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadZeroPose" title="Permalink to this definition">¶</a></dt>
<dd><p>load the zeroPose form the internal dict</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – optional, load at subSystem level for given nodes</li>
<li><strong>skipAttrs</strong> – optional list of attrs to skip during the load</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.getAnimationRange">
<code class="descname">getAnimationRange</code><span class="sig-paren">(</span><em>nodes=None</em>, <em>setTimeline=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.getAnimationRange" title="Permalink to this definition">¶</a></dt>
<dd><p>return the extend of the animation range for this rig and / or the given controllers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – if given only return the extent of the animation data from the given nodes</li>
<li><strong>setTimeLine</strong> – if True set the playback timeranges also, default=False</li>
<li><strong>decimals</strong> – int -1 default, this is the number of decimal places in the return, -1 = no clamp</li>
<li><strong>transforms_only</strong> – if True we only test translate (animCurveTL) and rotate (animCurveTA) data, added for skeleton fbx baked tests</li>
<li><strong>skip_static</strong> – if True we ignore static curves and return [], else we return
the key bounds for the static keys, ignoring the keyValues</li>
<li><strong>bounds_only</strong> – if True we only return the key bounds, first and last key times,
else we look at the changing values to find the bounds</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.keyChildren">
<code class="descname">keyChildren</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>walk=True</em>, <em>mAttrs=None</em>, <em>cAttrs=[]</em>, <em>nAttrs=[]</em>, <em>shapes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.keyChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>setKey on the systems controllers with options to control what gets keyed
via the standard getChildren <a href="#id17"><span class="problematic" id="id18">*</span></a>args which are passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to check, if None process the entire rig via all the flags which are passed into the getChildren call</li>
<li><strong>walk</strong> – walk all subMeta connections and include all their children too</li>
<li><strong>mAttrs</strong> – only search connected mNodes that pass the given attribute filter (attr is at the metaSystems level)</li>
<li><strong>cAttrs</strong> – only pass connected children whos connection to the mNode matches the given attr (accepts wildcards)</li>
<li><strong>nAttrs</strong> – search returned MayaNodes for given set of attrs and only return matched nodes</li>
<li><strong>shapes</strong> – now set to false to avoid keying all exposed Arnold shape attributes! We do however respect the animators
set key options and if they’ve specifically set shapes to key, we pick that up and respect it</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.hasKeys">
<code class="descname">hasKeys</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>walk=True</em>, <em>returnCtrls=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.hasKeys" title="Permalink to this definition">¶</a></dt>
<dd><p>return True if any of the rig’s controllers have existing
animation curve/key data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nodes</strong> – nodes to check, if None process the entire rig</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.cutKeys">
<code class="descname">cutKeys</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>reset=True</em>, <em>walk=True</em>, <em>verbose=False</em>, <em>selected=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.cutKeys" title="Permalink to this definition">¶</a></dt>
<dd><p>cut all animation keys from the rig and reset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – if passed in only cutKeys on given nodes</li>
<li><strong>reset</strong> – if true reset the rig after key removal</li>
<li><strong>walk</strong> – True by default, walk the mRig structures to find all children</li>
<li><strong>verbose</strong> – raise the confirm dialog</li>
<li><strong>selected</strong> – this is primary for the DAG menus in ProPack, rather than pass in nodes we
find all children of this mRig and compare the selected nodes against that,
only cutting those nodes that are part of this mRig</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.saveAnimation">
<code class="descname">saveAnimation</code><span class="sig-paren">(</span><em>filepath=None</em>, <em>incRoots=True</em>, <em>useFilter=True</em>, <em>timerange=()</em>, <em>storeThumbnail=False</em>, <em>force=False</em>, <em>userInfoData=''</em>, <em>autorange=True</em>, <em>buffer_ends=True</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.saveAnimation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>: PRO_PACK :</dt>
<dd>Binding of the animMap format for storing animation data out to file</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – r9Anim file to load</li>
<li><strong>incRoots</strong> – do we include the root node in the save, in metaRig case this is ctrl_main</li>
<li><strong>useFilter</strong> – do we process all children of this rig or just selected</li>
<li><strong>timerange</strong> – specify a timerange to store, If no timerange is passed
then it will use the current timeLine PlaybackRange, OR if you have a
highlighted range of time selected (in red) it’ll use this instead.</li>
<li><strong>storeThumbnail</strong> – this will be an avi but currently it’s a pose thumbnail</li>
<li><strong>force</strong> – allow force write on a read only file</li>
<li><strong>userInfoData</strong> – user information used by the AnimStore UI only</li>
<li><strong>autorange</strong> – if True (default) and you pass no timerange in then the code will auto-resolve the timerange from
the current playback timeranges. If this is False and you pass in no timerange then the code will use the full
bounds of the curves themselves, saving all key data for the objects regardless of the current timelines.
This is designed to be run with the “manageRanges=3” flag in the loadAnim code so we can save and restore
entire animation files via r9Anim format. This flag is ignored if timerange is passed as an arg</li>
<li><strong>buffer_ends</strong> – Oct 2022 : new functionality that will temporarily insert start and end frame keys into the data
before saving to ensure sparce baked data, particularly looping data, is maintained. We manage the tangents so
that the data is restored with exactly the same in and out shape regardless of the lack of initial key. Note that
this, like Maya itself, requires us to change the key tangents of the keys either side of the start and end frames
to ‘fixed’ to best maintain the curve shape.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.animMap_postprocess">
<code class="descname">animMap_postprocess</code><span class="sig-paren">(</span><em>feedback=None</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.animMap_postprocess" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>: PRO_PACK :</dt>
<dd>Added to be Overloaded at the class level!</dd>
</dl>
<p>Call passed into the animMap class and run AFTER the r9Anim file is loaded
on the MetaRig, this allows you to add functionality to the base load call to
extract extra data from the animMap and act upon it. This allows us to act on the
animMap stored on the class object and rebuild data from the infoDict if required.
We use this to rebuild audio links, exporter nodes and any other data that’s required
to be restored from the gathered info</p>
<p>self.animCache.infoDict</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>feedback</strong> – data passed back into the call by the main loadAnimation func</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>see the following functions in the ProPack &gt; metadata_pro.Pro_MetaRig_Base class for more detailed information</p>
<ul class="simple">
<li>metadata_pro.Pro_MetaRig_Base.animMap_restore_export_data</li>
<li>metadata_pro.Pro_MetaRig_Base.animMap_restore_audio_data</li>
</ul>
<p class="last">and all animMap_** functions as these expand</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.animMap_preprocess">
<code class="descname">animMap_preprocess</code><span class="sig-paren">(</span><em>feedback</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.animMap_preprocess" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>: PRO_PACK :</dt>
<dd>Added to be Overloaded at the class level!</dd>
</dl>
<p>Call passed into the animMap class and run BEFORE the r9Anim file is loaded
on the MetaRig, this allows you to add functionality to the base load call to
extract extra data from the animMap and act upon it. This allows us to act on the
animMap stored on the class object and rebuild data from the infoDict if required.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadAnimation_postload_call">
<code class="descname">loadAnimation_postload_call</code><span class="sig-paren">(</span><em>feedback=None</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadAnimation_postload_call" title="Permalink to this definition">¶</a></dt>
<dd><p># DEPRECATED FUNCTION - replaced with self.animMap_postprocess</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.loadAnimation">
<code class="descname">loadAnimation</code><span class="sig-paren">(</span><em>filepath=None, incRoots=True, useFilter=True, loadAsStored=True, loadFromFrm=0, loadFromTimecode=False, timecodeBinding=[None, None], referenceNode=None, relativeRots='projected', relativeTrans='projected', manageRanges=1, manageFileName=True, keyStatics=False, blendRange=None, merge=False, matchMethod='metaData', smartbake=False, loadInternalRig=False, maintain_parents=False, *args, **kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.loadAnimation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>: PRO_PACK :</dt>
<dd>Binding of the animMap format for loading animation data from
an r9Anim file. The base binding of the animation format is the DataMap object
in the Red9_PoseSaver so many of the exposed flags come from there.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – r9Anim file to load</li>
<li><strong>incRoots</strong> – do we include the root node in the load, in metaRig case this is ctrl_main</li>
<li><strong>useFilter</strong> – do we process all children of this rig or just selected</li>
<li><strong>loadAsStored</strong> – load the data from the timerange stored</li>
<li><strong>loadFromFrm</strong> – load the data from a given frame, this requires the loadAsStored=False else is ignored</li>
<li><strong>loadFromTimecode</strong> – load against a given SMPTE timecode / frm binding, calculating the offset of
the data to load against a given timecode reference. IF timecodeBinding isn’t set then we gather the reference timecode from
the mRig’s internal data, else we use the timecode binding supplied</li>
<li><strong>timecodeBinding</strong> – (frm, str(‘00:00:00:00’))  Tuple where the first arg is the frame at which the second arg’s SMPTE timecode
has been set as reference, basically we’re saying that the timecode at frm is x</li>
<li><strong>referenceNode</strong> – load relative to the given node</li>
<li><strong>relativeRots</strong> – ‘projected’ or ‘absolute’ - how to calculate the offset, default=’projected’</li>
<li><strong>relativeTrans</strong> – ‘projected’ or ‘absolute’ - how to calculate the offset, default=’projected’</li>
<li><strong>manageRanges</strong> – do we (0, 1, 2, 3) = leave, extend, set or set original playbackRanges for the Maya playback ranges according to the anim data loaded</li>
<li><strong>manageFileName</strong> – if True and the current Maya scene has no filename other than a blank scene (ie freshly loaded rig)
then we take the r9Anim’s filename and rename the Maya scene accordingly</li>
<li><strong>keyStatics</strong> – if True then we key everything in the data at startFrame &amp; endFrame so that all non-keyed and static
attrs that are stored internally as a pose are keyed.</li>
<li><strong>blendRange</strong> – None or int : None is default. If an int is passed then we use this as the hold range for the data, setting a key at
time=[startFarme-blendRange, endFarme+blendRange] to hold the current data before we load the new keys. Note that this also turns
on the keyStatics to ensure the data is preserved</li>
<li><strong>merge</strong> – if True we allow the data to be merged over any current keys, else we cut all keys in the load range first</li>
<li><strong>matchMethod</strong> – internal matching method used to match nodes to the stored data</li>
<li><strong>smartbake</strong> – only valid if we’re loading with a referenceNode, this tries to respect current keys when doing the processing rather than frame baking</li>
<li><strong>loadInternalRig</strong> – If True and the r9Anim was created from a rig that was referenced then re-create that reference and load the r9Anim data onto
the resulting nodes. This is used in the Direct Load calls as the prime way to import the rigs prior to loading</li>
<li><strong>maintain_parents</strong> – Only supported with mRig load data. This preserves any parentSwitching mismatches between the stored data
and the current rig key, current spaces are maintained and the anim data compensated accordingly. This only checks those nodes
in the filterPriority list as those are the ones that get recalculated in worldSpace after the data load.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>: additional <a href="#id19"><span class="problematic" id="id20">**</span></a>KWS passed in and / or accepted in the ProPack codebase :</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>manageExport</strong> – <p>if running the Red9Pro Exporter systems this will rebuild the export Tag data directly
from the r9Anim file’s infoData block:</p>
<blockquote>
<div><ul>
<li>False : don’t restore any exportData,</li>
<li>[] : if you pass in a list then we take that list and match internal exportloop names to it</li>
<li>’byName’ : restore only exportLoops who name matches the r9Anim’s name</li>
<li>’byRange’: restore exportLoops that fall within the timerange of the imported r9Anim</li>
<li>’byRange_start’ : restore exportLoops that start after the timerange of the importer r9Anim (ignore end time data)</li>
<li>’byRange_end’ : restore exportLoops that end before the timerange of the importer r9Anim (ignore start time data)</li>
<li>’byAll’ : restore ALL exportLoops in the r9Anim infoData block</li>
</ul>
</div></blockquote>
</li>
<li><strong>manageAudio</strong> – If running the Red9Pro Exporter systems this will rebuild the Audio Node data directly, taking
the same matching flags as the manageExport kws above
from the r9Anim file’s infoData block   (False, [], ‘byName’, ‘byRange’, ‘byRange_start’, ‘byRange_end’, ‘byAll’)</li>
<li><strong>manageImagePlanes</strong> – if we’re dealing with a sub-class of the Pro_MetaRig_FacialUI the restore the ImagePlane data,
this is a simple bool. This creates the imageplane, binds it to the facial UI, offsets it, loads the imagedata, sets the
width/height and frameoffset.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>After the anim load the animData is stored on this instance as self.animCache which then
exposes all the data for further functions if needed.</p>
<ul class="last simple">
<li>self.animCache.infoDict = gatherInfo / general secondary data block on the file and pose.</li>
<li>self.animCache.poseDict = the animation and pose data dict.</li>
<li>self.animCache.skeletonDict = the pose data dict purely for the skeleton, used in compare functions.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">because imagePlanes in Maya are so heavily bound to AETemplate callbacks you need to flick over to the attribute editor
to correctly initialize any image sequence</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a href="#id21"><span class="problematic" id="id22">**</span></a>kws are passed directly into BOTH the AnimMap class and the animMap_postprocess
so that we can bounce additional <a href="#id23"><span class="problematic" id="id24">**</span></a>kws into these funcs without having to specify everything,
this allows us to modify the behaviour on a case by case basis for clients</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.Timecode">
<code class="descname">Timecode</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.Timecode" title="Permalink to this definition">¶</a></dt>
<dd><p>: PRO_PACK : bind the Pro Timecode class to the node. The Timecode object is now cached
to the instance rather than being instantiated on ach call.</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_ctrlnode">
<code class="descname">timecode_ctrlnode</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_ctrlnode" title="Permalink to this definition">¶</a></dt>
<dd><p>: PRO_PACK : return the actual node that the timecode data is stamped onto in the rig</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_isValid">
<code class="descname">timecode_isValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_isValid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>: PRO_PACK <span class="classifier-delimiter">:</span> <span class="classifier">check if the timecode is in a valid format, particularly the sample_rate attr</span></dt>
<dd>which must NOT be set to Zero</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_get">
<code class="descname">timecode_get</code><span class="sig-paren">(</span><em>atFrame=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_get" title="Permalink to this definition">¶</a></dt>
<dd><p>: PRO PACK : get the timecode back from the rig</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_addAttrs">
<code class="descname">timecode_addAttrs</code><span class="sig-paren">(</span><em>tc=''</em>, <em>propagate=False</em>, <em>timerange=()</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_addAttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>: PRO PACK : add the timecode attributes and push the given timecode
to the mRigs timecode node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tc</strong> – timecode to set</li>
<li><strong>propagate</strong> – do we just set the attrs or push the counter keys</li>
<li><strong>timerange</strong> – If propagate then this is an optional timerange over which to set the data</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_setTimecode">
<code class="descname">timecode_setTimecode</code><span class="sig-paren">(</span><em>tc=''</em>, <em>propagate=False</em>, <em>ui=False</em>, <em>timerange=()</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_setTimecode" title="Permalink to this definition">¶</a></dt>
<dd><p>: PRO PACK : wrap over the timecode_addAttrs but exposes the enterTimecode ui</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tc</strong> – timecode to set</li>
<li><strong>propagate</strong> – do we just set the attrs or push the counter keys, if the UI is True then this is True by default</li>
<li><strong>ui</strong> – do we launch the Timecode UI to enter a specific timecode manually</li>
<li><strong>timerange</strong> – If propagate then this is an optional timerange over which to set the data</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_hasTimeCode">
<code class="descname">timecode_hasTimeCode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_hasTimeCode" title="Permalink to this definition">¶</a></dt>
<dd><p>: PRO PACK : simple return to check if the system has the Pro Timecode
systems bound to it</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRig.timecode_remove">
<code class="descname">timecode_remove</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRig.timecode_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>: PRO PACK : remove the Timecode attrs and system from this mRig</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaRigSubSystem">
<em class="property">class </em><code class="descname">MetaRigSubSystem</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSubSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></code></a></p>
<p>SubClass of the MRig, designed to organize Rig sub-systems (ie L_ArmSystem, L_LegSystem..)
within a complex rig structure. This or MetaRig should have the Controllers wired to it</p>
<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRigSubSystem.SupportNode">
<code class="descname">SupportNode</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSubSystem.SupportNode" title="Permalink to this definition">¶</a></dt>
<dd><p>return the connected Support mNode regardless of the wire used to connect it</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this is setup to use the Red9Pro Puppet wire conventions when multiple connected
support nodes are found. The idea being that there is always 1 main support for a system
and the naming convention of the mNodeID reflects that ie: L_ArmSystem and L_ArmSupport</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRigSubSystem.getChildSystem_by_Type">
<code class="descname">getChildSystem_by_Type</code><span class="sig-paren">(</span><em>systemType</em>, <em>walk=True</em>, <em>stepover=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSubSystem.getChildSystem_by_Type" title="Permalink to this definition">¶</a></dt>
<dd><p>return a child MetaSubsystem by its “systemType”</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>systemType</strong> – the type of systems stored in the “systemType” attr on the mSubsystem</li>
<li><strong>walk</strong> – walk all child mNode systems</li>
<li><strong>stepover</strong> – walk over non matching systems else a tree would stop</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaRigSubSystem.build_class">
<code class="descname">build_class</code><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSubSystem.build_class" title="Permalink to this definition">¶</a></dt>
<dd><p>get the internal build class for this compound</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaRigSupport">
<em class="property">class </em><code class="descname">MetaRigSupport</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSupport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>SubClass of MetaClass, designed to organize support nodes, solvers and other internal
nodes within a complex rig structure which you may need to ID at a later date.
Controllers should NOT be wired to this node</p>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaRigSupport.addSupportNode">
<code class="descname">addSupportNode</code><span class="sig-paren">(</span><em>node</em>, <em>attr</em>, <em>boundData=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaRigSupport.addSupportNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single MAYA node flagged as a SUPPORT node of managed type</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – Maya node to add</li>
<li><strong>attr</strong> – Attr name to assign this too</li>
<li><strong>boundData</strong> – {} Data to set on the given node as attrs</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaFacialRig">
<em class="property">class </em><code class="descname">MetaFacialRig</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaFacialRig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></code></a></p>
<p>SubClass of the MetaRig, designed to be manage Facial systems in the MetaData
Dag tree for organizing Facial Controllers and support nodes</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaFacialRigSupport">
<em class="property">class </em><code class="descname">MetaFacialRigSupport</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaFacialRigSupport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>SubClass of the MetaClass, designed to organize support nodes, solvers and other internal
nodes within a complex rig structure which you may need to ID at a later date.
Controllers should NOT be wired to this node</p>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaFacialRigSupport.addSupportNode">
<code class="descname">addSupportNode</code><span class="sig-paren">(</span><em>node</em>, <em>attr</em>, <em>boundData=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaFacialRigSupport.addSupportNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single MAYA node flagged as a SUPPORT node of managed type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – Maya node to add</li>
<li><strong>attr</strong> – Attr name to assign this too</li>
<li><strong>boundData</strong> – {} Data to set on the given node as attrs</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode">
<em class="property">class </em><code class="descname">MetaHIKCharacterNode</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></code></a></p>
<p>Casting HIK directly to a metaClass so it’s treated as meta by default.
Why the hell not, it’s a complex character node that is default in Maya
and useful for management in the systems</p>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.isValid">
<code class="descname">isValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.isValid" title="Permalink to this definition">¶</a></dt>
<dd><p>simple check to see if this definition is still wired to a skeleton,
if the skeleton was deleted then the definition never gets cleaned up!!
Messy Sodding Maya!</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.getHIKPropertyStateNode">
<code class="descname">getHIKPropertyStateNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.getHIKPropertyStateNode" title="Permalink to this definition">¶</a></dt>
<dd><p>return the HIK Property node as a class for easy management</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.getHIKControlSetNode">
<code class="descname">getHIKControlSetNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.getHIKControlSetNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete hik node and dependency nodes
:return:</p>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.openui">
<em class="property">static </em><code class="descname">openui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.openui" title="Permalink to this definition">¶</a></dt>
<dd><p>Open hik UI</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.lock">
<code class="descname">lock</code><span class="sig-paren">(</span><em>force_lock=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.lock" title="Permalink to this definition">¶</a></dt>
<dd><p>lock hik characterisation
:return: True if lock False if not lock</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.unLock">
<code class="descname">unLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.unLock" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock hik characterisation</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.isLocked">
<code class="descname">isLocked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.isLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>return True if the HIK characterization is locked</p>
</dd></dl>

<dl class="staticmethod">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.getCurrentCharacter">
<em class="property">static </em><code class="descname">getCurrentCharacter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.getCurrentCharacter" title="Permalink to this definition">¶</a></dt>
<dd><p>get current hik character
:return: current hik charactre name</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.setascurrentcharacter">
<code class="descname">setascurrentcharacter</code><span class="sig-paren">(</span><em>openui=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.setascurrentcharacter" title="Permalink to this definition">¶</a></dt>
<dd><p>set current mNode as hikcurrentcharacter</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.checkcharacterization">
<code class="descname">checkcharacterization</code><span class="sig-paren">(</span><em>openui=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.checkcharacterization" title="Permalink to this definition">¶</a></dt>
<dd><p>check that the hikNode characterisation is valid. This is reflected in the
Maya HIK UI by the warning icon in the top right if the joints aren’t aligned</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>openui</strong> – if True we open the UI to show the status, else we just return the status</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if valid, False if invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKCharacterNode.checkRotate_Limits">
<code class="descname">checkRotate_Limits</code><span class="sig-paren">(</span><em>unlock_all=False</em>, <em>ignore=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKCharacterNode.checkRotate_Limits" title="Permalink to this definition">¶</a></dt>
<dd><p>check if any of the defined joints in the characterization have rotation limits enabled.
These are separate to the actual joint limits in Maya and more difficult to get a good
overview for debugging, hence this proc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>unlock_all</strong> – If true and any of the rotate limits have been set  which will ignore these
strings in the checked attributes, helps debugging specific errors</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaHIKControlSetNode">
<em class="property">class </em><code class="descname">MetaHIKControlSetNode</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKControlSetNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></code></a></p>
<p>Casting HIK directly to a metaClass so it’s treated as meta by default.
Why the hell not, it’s a complex character node that is default in Maya
and useful for management in the systems</p>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKControlSetNode.getHIKCharacterNode">
<code class="descname">getHIKCharacterNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKControlSetNode.getHIKCharacterNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKControlSetNode.getChildren">
<code class="descname">getChildren</code><span class="sig-paren">(</span><em>walk=False</em>, <em>mAttrs=None</em>, <em>cAttrs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKControlSetNode.getChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Carefully over-loaded for HIK system</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode">
<em class="property">class </em><code class="descname">MetaHIKPropertiesNode</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>Casting HIK Properties to a Meta class for easy managing</p>
<p>** PRO PACK BASED SETUP FOR THE REMAPPING HANDLERS **</p>
<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.floor_contact">
<code class="descname">floor_contact</code><em class="property"> = ['FootBottomToAnkle', 'FootBackToAnkle', 'FootMiddleToAnkle', 'FootFrontToMiddle', 'FootInToAnkle', 'FootOutToAnkle', 'HandBottomToWrist', 'HandBackToWrist', 'HandMiddleToWrist', 'HandFrontToMiddle', 'HandInToWrist', 'HandOutToWrist']</em><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.floor_contact" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.tips_finger_toes">
<code class="descname">tips_finger_toes</code><em class="property"> = ['LeftHandThumbTip', 'LeftHandIndexTip', 'LeftHandMiddleTip', 'LeftHandRingTip', 'LeftHandPinkyTip', 'LeftHandExtraFingerTip', 'RightHandThumbTip', 'RightHandIndexTip', 'RightHandMiddleTip', 'RightHandRingTip', 'RightHandPinkyTip', 'RightHandExtraFingerTip', 'LeftFootThumbTip', 'LeftFootIndexTip', 'LeftFootMiddleTip', 'LeftFootRingTip', 'LeftFootPinkyTip', 'LeftFootExtraFingerTip', 'RightFootThumbTip', 'RightFootIndexTip', 'RightFootMiddleTip', 'RightFootRingTip', 'RightFootPinkyTip', 'RightFootExtraFingerTip']</em><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.tips_finger_toes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.roll_pitch">
<code class="descname">roll_pitch</code><em class="property"> = ['RollExtractionMode', 'LeftForeArmRollEx', 'LeftArmRollEx', 'RightForeArmRollEx', 'RightArmRollEx', 'rightShoulderRoll', 'LeftLegRollEx', 'LeftUpLegRollEx', 'RightLegRollEx', 'RightUpLegRollEx', 'LeftArmRoll', 'LeftArmRollMode', 'LeftForeArmRoll', 'LeftForeArmRollMode', 'LeftLegRoll', 'LeftLegRollMode', 'LeftUpLegRoll', 'LeftUpLegRollMode', 'RightArmRoll', 'RightArmRollMode', 'RightForeArmRoll', 'RightForeArmRollMode', 'RightLegRoll', 'RightLegRollMode', 'RightUpLegRoll', 'RightUpLegRollMode', 'LeftLegFullRollExtraction', 'LeftLegFullRollExtractionMode', 'ParamLeafLeftUpLegRoll1', 'ParamLeafLeftUpLegRoll1Mode', 'ParamLeafLeftUpLegRoll2', 'ParamLeafLeftUpLegRoll2Mode', 'ParamLeafLeftUpLegRoll3', 'ParamLeafLeftUpLegRoll3Mode', 'ParamLeafLeftUpLegRoll4', 'ParamLeafLeftUpLegRoll4Mode', 'ParamLeafLeftUpLegRoll5', 'ParamLeafLeftUpLegRoll5Mode', 'leftHipRoll', 'ParamLeafLeftLegRoll1', 'ParamLeafLeftLegRoll1Mode', 'ParamLeafLeftLegRoll2', 'ParamLeafLeftLegRoll2Mode', 'ParamLeafLeftLegRoll3', 'ParamLeafLeftLegRoll3Mode', 'ParamLeafLeftLegRoll4', 'ParamLeafLeftLegRoll4Mode', 'ParamLeafLeftLegRoll5', 'ParamLeafLeftLegRoll5Mode', 'leftKneeRoll', 'LeftKneeKillPitch', 'RightLegFullRollExtraction', 'RightLegFullRollExtractionMode', 'ParamLeafRightUpLegRoll1', 'ParamLeafRightUpLegRoll1Mode', 'ParamLeafRightUpLegRoll2', 'ParamLeafRightUpLegRoll2Mode', 'ParamLeafRightUpLegRoll3', 'ParamLeafRightUpLegRoll3Mode', 'ParamLeafRightUpLegRoll4', 'ParamLeafRightUpLegRoll4Mode', 'ParamLeafRightUpLegRoll5', 'ParamLeafRightUpLegRoll5Mode', 'rightHipRoll', 'ParamLeafRightLegRoll1', 'ParamLeafRightLegRoll1Mode', 'ParamLeafRightLegRoll2', 'ParamLeafRightLegRoll2Mode', 'ParamLeafRightLegRoll3', 'ParamLeafRightLegRoll3Mode', 'ParamLeafRightLegRoll4', 'ParamLeafRightLegRoll4Mode', 'ParamLeafRightLegRoll5', 'ParamLeafRightLegRoll5Mode', 'rightKneeRoll', 'RightKneeKillPitch', 'LeftArmFullRollExtraction', 'LeftArmFullRollExtractionMode', 'ParamLeafLeftArmRoll1', 'ParamLeafLeftArmRoll1Mode', 'ParamLeafLeftArmRoll2', 'ParamLeafLeftArmRoll2Mode', 'ParamLeafLeftArmRoll3', 'ParamLeafLeftArmRoll3Mode', 'ParamLeafLeftArmRoll4', 'ParamLeafLeftArmRoll4Mode', 'ParamLeafLeftArmRoll5', 'ParamLeafLeftArmRoll5Mode', 'leftShoulderRoll', 'ParamLeafLeftForeArmRoll1', 'ParamLeafLeftForeArmRoll1Mode', 'ParamLeafLeftForeArmRoll2', 'ParamLeafLeftForeArmRoll2Mode', 'ParamLeafLeftForeArmRoll3', 'ParamLeafLeftForeArmRoll3Mode', 'ParamLeafLeftForeArmRoll4', 'ParamLeafLeftForeArmRoll4Mode', 'ParamLeafLeftForeArmRoll5', 'ParamLeafLeftForeArmRoll5Mode', 'leftElbowRoll', 'LeftElbowKillPitch', 'RightArmFullRollExtraction', 'RightArmFullRollExtractionMode', 'ParamLeafRightArmRoll1', 'ParamLeafRightArmRoll1Mode', 'ParamLeafRightArmRoll2', 'ParamLeafRightArmRoll2Mode', 'ParamLeafRightArmRoll3', 'ParamLeafRightArmRoll3Mode', 'ParamLeafRightArmRoll4', 'ParamLeafRightArmRoll4Mode', 'ParamLeafRightArmRoll5', 'ParamLeafRightArmRoll5Mode', 'rightShoulderRoll', 'ParamLeafRightForeArmRoll1', 'ParamLeafRightForeArmRoll1Mode', 'ParamLeafRightForeArmRoll2', 'ParamLeafRightForeArmRoll2Mode', 'ParamLeafRightForeArmRoll3', 'ParamLeafRightForeArmRoll3Mode', 'ParamLeafRightForeArmRoll4', 'ParamLeafRightForeArmRoll4Mode', 'ParamLeafRightForeArmRoll5', 'ParamLeafRightForeArmRoll5Mode', 'RightElbowKillPitch']</em><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.roll_pitch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.measurements">
<code class="descname">measurements</code><em class="property"> = ['FootBottomToAnkle', 'FootBackToAnkle', 'FootMiddleToAnkle', 'FootFrontToMiddle', 'FootInToAnkle', 'FootOutToAnkle', 'HandBottomToWrist', 'HandBackToWrist', 'HandMiddleToWrist', 'HandFrontToMiddle', 'HandInToWrist', 'HandOutToWrist', 'LeftHandThumbTip', 'LeftHandIndexTip', 'LeftHandMiddleTip', 'LeftHandRingTip', 'LeftHandPinkyTip', 'LeftHandExtraFingerTip', 'RightHandThumbTip', 'RightHandIndexTip', 'RightHandMiddleTip', 'RightHandRingTip', 'RightHandPinkyTip', 'RightHandExtraFingerTip', 'LeftFootThumbTip', 'LeftFootIndexTip', 'LeftFootMiddleTip', 'LeftFootRingTip', 'LeftFootPinkyTip', 'LeftFootExtraFingerTip', 'RightFootThumbTip', 'RightFootIndexTip', 'RightFootMiddleTip', 'RightFootRingTip', 'RightFootPinkyTip', 'RightFootExtraFingerTip']</em><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.measurements" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.get_mapping">
<code class="descname">get_mapping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.get_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current mapping state and return a dict {attr:val, …}</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.get_non_default_values">
<code class="descname">get_non_default_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.get_non_default_values" title="Permalink to this definition">¶</a></dt>
<dd><p>return values that differ from the default values and have therefore been set by the user</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.reset_defaults">
<code class="descname">reset_defaults</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.reset_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the default mapping property states</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.save_mapping">
<code class="descname">save_mapping</code><span class="sig-paren">(</span><em>filepath</em>, <em>skip_measurements=True</em>, <em>skip_rolls=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.save_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>save the current mapping to file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – filepath to store the mapping out too</li>
<li><strong>skip_measurements</strong> – if true (default) we do not store those attrs that are skeleton specific
only those which control the remapping</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHIKPropertiesNode.load_mapping">
<code class="descname">load_mapping</code><span class="sig-paren">(</span><em>filepath</em>, <em>changes_only=True</em>, <em>verbose=True</em>, <em>skip_measurements=True</em>, <em>skip_rolls=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHIKPropertiesNode.load_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>load a previous mapping back from file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – filepath to load the mapping from</li>
<li><strong>changes_only</strong> – only set those attrs that have changed (limits errors)</li>
<li><strong>verbose</strong> – report back all data set, changed or failed</li>
<li><strong>skip_measurements</strong> – if true (defulat) we do not store those attrs that are skeleton specific
only those which control the remapping</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.monitorHUDaddCBAttrs">
<code class="descname">monitorHUDaddCBAttrs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.monitorHUDaddCBAttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>ChannelBox wrappers for the HUD :
Adds selected attrs from the CB to a MetaHUD node for monitoring,
if HUD node already exists this will simply add more attrs to it</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.monitorHUDManagement">
<code class="descname">monitorHUDManagement</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.monitorHUDManagement" title="Permalink to this definition">¶</a></dt>
<dd><p>ChannelBox wrappers for the HUD : kill any current MetaHUD headsUpDisplay blocks</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.monitorHUDremoveCBAttrs">
<code class="descname">monitorHUDremoveCBAttrs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.monitorHUDremoveCBAttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>ChannelBox wrappers for the HUD : remove attrs from the MetaHUD</p>
</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.hardKillMetaHUD">
<code class="descname">hardKillMetaHUD</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.hardKillMetaHUD" title="Permalink to this definition">¶</a></dt>
<dd><p>If the MetaNodes are left behind in a scene and you can’t remove them
then this is a hard coded kill to remove the hud element. This situation
happens if you’d deleted the MetaHUDNode but left the draw on, meaning
we now have invalid HUD data drawn.</p>
</dd></dl>

<dl class="class">
<dt id="Red9.core.Red9_Meta.MetaHUDNode">
<em class="property">class </em><code class="descname">MetaHUDNode</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>SubClass of the MetaClass, designed as a simple interface
for HUD management in Maya. Any monitored attrs added to the MetaNode
will show in the HUD when drawn.</p>
<p>The idea is that we have a single MetaNode with attrs that are monitored
and managed for HUD display. To get an attr onto the HUD all you need to do
is add it using addMonitoredAttr(), then drawHUD(). All I do is connect the HUD
attr to the attr that you want to monitor, it just sits as a new wired node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">TODO:</th><td class="field-body">Look if we can link the Section and Block attrs to the refresh func
via an attrChange callback</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.addMonitoredAttr">
<code class="descname">addMonitoredAttr</code><span class="sig-paren">(</span><em>attr</em>, <em>value=None</em>, <em>attrType=None</em>, <em>refresh=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.addMonitoredAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper that not only adds an attr to the metaNode, but also adds it
to the internal list of attributes that are monitored and added
to the HUD when drawn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> – attr to be added to the node for monitoring in the HUD</li>
<li><strong>value</strong> – Initial value of the attr so the node can figure out what type of attr it is</li>
<li><strong>attrType</strong> – specifiy the attr type directly</li>
<li><strong>refresh</strong> – whether to refresh the HUD after adding a new attr</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this ties in with the default addAttr call hence the args are very similar in function</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.removeMonitoredAttr">
<code class="descname">removeMonitoredAttr</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.removeMonitoredAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an attr from the MetaNode and refresh the HUD to reflect the removal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>attr</strong> – attr to be removed from monitoring</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.getHudDisplays">
<code class="descname">getHudDisplays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.getHudDisplays" title="Permalink to this definition">¶</a></dt>
<dd><p>each line in the HUD is actually a separate HUD in itself so we need
to carefully manage this list</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.drawHUD">
<code class="descname">drawHUD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.drawHUD" title="Permalink to this definition">¶</a></dt>
<dd><p>Push the monitored attrs up to the Maya HUD in the viewport</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.getConnectedAttr">
<code class="descname">getConnectedAttr</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.getConnectedAttr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.getConnectedNode">
<code class="descname">getConnectedNode</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.getConnectedNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.setSlidertoAttr">
<code class="descname">setSlidertoAttr</code><span class="sig-paren">(</span><em>slider</em>, <em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.setSlidertoAttr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.resetSlider">
<code class="descname">resetSlider</code><span class="sig-paren">(</span><em>slider</em>, <em>attr</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.resetSlider" title="Permalink to this definition">¶</a></dt>
<dd><p>If the HUD is made up of sliders this resets them</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>slider</strong> – slider to reset in the HUD</li>
<li><strong>attr</strong> – attr to reset on the mNode</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.showHud">
<code class="descname">showHud</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.showHud" title="Permalink to this definition">¶</a></dt>
<dd><p>manage the visibility state of the HUD</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>value</strong> – show or hide the HUD</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.killHud">
<code class="descname">killHud</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.killHud" title="Permalink to this definition">¶</a></dt>
<dd><p>kill the HUD display altogether</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.refreshHud">
<code class="descname">refreshHud</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.refreshHud" title="Permalink to this definition">¶</a></dt>
<dd><p>Refresh the HUD by killing it and re-drawing it from scratch</p>
</dd></dl>

<dl class="method">
<dt id="Red9.core.Red9_Meta.MetaHUDNode.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.MetaHUDNode.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>full cleanup, remove the metaNode and all HUDs in the process</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Red9.core.Red9_Meta.metaData_sceneCleanups">
<code class="descname">metaData_sceneCleanups</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.core.Red9_Meta.metaData_sceneCleanups" title="Permalink to this definition">¶</a></dt>
<dd><p>Registered on SceneOpen and SceneNew callbacks so that the MetaData Cache is cleared and
any registered HUD is killed off</p>
</dd></dl>

</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Red9_General.html" class="btn btn-neutral float-left" title="Red9_General" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Red9_PoseSaver.html" class="btn btn-neutral float-right" title="Red9_PoseSaver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Red9 Consultancy Limited.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>