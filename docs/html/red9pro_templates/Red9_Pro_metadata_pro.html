<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pro_Pack : metadata_pro &mdash; Red9 3.0 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Pro_Pack : optimiser" href="Red9_Pro_optimiser.html" />
    <link rel="prev" title="Pro_Pack : importexport" href="Red9_Pro_importexport.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Red9<img src="../_static/Red9_ProPack_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_AnimationUtils.html">Red9_AnimationUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Audio.html">Red9_Audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Core.html">Red9_CoreUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_General.html">Red9_General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Meta.html">Red9_Meta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_PoseSaver.html">Red9_PoseSaver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Setup.html">Red9_Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Tools.html">Red9_Tools</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_anim_map.html">Pro_Pack : anim_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_animation.html">Pro_Pack : animation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_audio.html">Pro_Pack : audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_export.html">Pro_Pack : exporter</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_general.html">Pro_Pack : general</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_importexport.html">Pro_Pack : importexport</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Pro_Pack : metadata_pro</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_optimiser.html">Pro_Pack : optimiser</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_project.html">Pro_Pack : project</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_r9data.html">Pro_Pack : r9Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_rigutils.html">Pro_Pack : rigutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_skining.html">Pro_Pack : skining</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_skinning.html">Pro_Pack : skinning</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_uibase.html">Pro_Pack : uibase</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_anim_binder.html">Pro_Pack : tools : anim_binder</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_anim_tools.html">Pro_Pack : tools : anim_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_health_manager.html">Pro_Pack : tools : health_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_metahuman_tools.html">Pro_Pack : tools : metahuman_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_project_manager.html">Pro_Pack : tools : project_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_rig_manager.html">Pro_Pack : tools : rig_manager</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Red9</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Pro_Pack : metadata_pro</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/red9pro_templates/Red9_Pro_metadata_pro.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="pro-pack-metadata-pro">
<h1>Pro_Pack : metadata_pro<a class="headerlink" href="#pro-pack-metadata-pro" title="Permalink to this headline">¶</a></h1>
<p>ProPack metadata module contains all the specifically built nodes for the
extended pipelines running under ProPack. These include our Red9Puppet and
the exporter and audio management systems. This is the very core of all the Red9
pipeline when running the Red9 Puppet rig.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># import statement for the module via the r9pro decompiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Red9.pro_pack</span> <span class="k">import</span> <span class="n">r9pro</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r9pmeta</span> <span class="o">=</span> <span class="n">r9pro</span><span class="o">.</span><span class="n">r9import</span><span class="p">(</span><span class="s1">&#39;r9pmeta&#39;</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="module-Red9.pro_pack.core.metadata_pro"></span><p>This module is extensions to the main metaData support through the Red9 StudioPack and
requires the StudioPack codebase to run</p>
<p class="rubric">Main Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pro_MetaRig_Base</span></code></a>(*args,&nbsp;**kws)</td>
<td>Red9 Puppet Rig bespoke Base Class for Rig system MetaRig core, this is a general extension to the default MetaRig to include systems such as the export handling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pro_MetaRig</span></code></a>(*args,&nbsp;**kws)</td>
<td>Red9 bespoke Puppet Rig system MetaRig core ;)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pro_MetaRig_SRC</span></code></a>(*args,&nbsp;**kws)</td>
<td>Red9 bespoke Puppet Rig system SRC Management Node</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Prop" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pro_MetaRig_Prop</span></code></a>(*args,&nbsp;**kws)</td>
<td>MetaRig subclass for Props - binds to the ExportTag_Prop class</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pro_MetaRig_Vehicle</span></code></a>(*args,&nbsp;**kws)</td>
<td>MetaRig subclass for Vehicles - binds to the ExportTag_Vehicle class</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_External" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_External"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pro_MetaRig_External</span></code></a>(*args,&nbsp;**kws)</td>
<td>MetaRig subclass - base class for external rigs being wired to the system,  unless being wired to simulate a Red9 Puppet wiring setup, usually with support from us directly - binds to the ExportTag_Character class</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_RigidBody" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_RigidBody"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pro_MetaRig_RigidBody</span></code></a>(*args,&nbsp;**kws)</td>
<td>MetaRig subclass for RigidBody style rigs - binds to the ExportTag_RigidBody class</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pro_MetaRig_FacialUI</span></code></a>(*args,&nbsp;**kws)</td>
<td>SubClass of the MetaRig, designed to manage facial board style controls for a facial system.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base" title="Red9.pro_pack.core.metadata_pro.ExportTag_Base"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExportTag_Base</span></code></a>(*args,&nbsp;**kws)</td>
<td>Generic Export base class inheriting from MetaClass.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Character" title="Red9.pro_pack.core.metadata_pro.ExportTag_Character"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExportTag_Character</span></code></a>(*args,&nbsp;**kws)</td>
<td>Export subclass for characters</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Facial" title="Red9.pro_pack.core.metadata_pro.ExportTag_Facial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExportTag_Facial</span></code></a>(*args,&nbsp;**kws)</td>
<td>Export subclass for Facial UI systems</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Prop" title="Red9.pro_pack.core.metadata_pro.ExportTag_Prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExportTag_Prop</span></code></a>(*args,&nbsp;**kws)</td>
<td>Export subclass for props</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Vehicle" title="Red9.pro_pack.core.metadata_pro.ExportTag_Vehicle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExportTag_Vehicle</span></code></a>(*args,&nbsp;**kws)</td>
<td>Export subclass for vehicles</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_RigidBody" title="Red9.pro_pack.core.metadata_pro.ExportTag_RigidBody"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExportTag_RigidBody</span></code></a>(*args,&nbsp;**kws)</td>
<td>Export subclass for rigid body style outputs, These are NON SKELETAL</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Environment" title="Red9.pro_pack.core.metadata_pro.ExportTag_Environment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExportTag_Environment</span></code></a>(*args,&nbsp;**kws)</td>
<td>Export subclass for environments</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode" title="Red9.pro_pack.core.metadata_pro.ExportLoopNode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExportLoopNode</span></code></a>(*args,&nbsp;**kws)</td>
<td>Base Export Timerange node, intended to hook to a valid ExportTag metaNode to define exact timeranges and paths etc.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.SceneMover" title="Red9.pro_pack.core.metadata_pro.SceneMover"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SceneMover</span></code></a>([compensate_node])</td>
<td>Scene Shift Handler : to move an entire Maya scene in world space under a managed node</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ImagePlane" title="Red9.pro_pack.core.metadata_pro.ImagePlane"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImagePlane</span></code></a>(*args,&nbsp;**kws)</td>
<td>base classs to manage and setup ImagePlanes within Maya, instanciated as a MetaNode for better back-end management and exposure of the base attributes directly on the class</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.AudioGroup" title="Red9.pro_pack.core.metadata_pro.AudioGroup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AudioGroup</span></code></a>(*args,&nbsp;**kws)</td>
<td>a simple node designed to group / link audio sound nodes to together so they can be linked to a character rig for export logic handling</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD" title="Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MetaTimeCodeHUD</span></code></a>(*args,&nbsp;**kws)</td>
<td>Generate’s a HUD node connected to the main timecode attrs, allows us to show the actual internal timecode attrs as their original SMPTE time’s</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.wire_controls_to_new_metarig">
<code class="descname">wire_controls_to_new_metarig</code><span class="sig-paren">(</span><em>nodes</em>, <em>name=None</em>, <em>mRig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.wire_controls_to_new_metarig" title="Permalink to this definition">¶</a></dt>
<dd><p>fast way to wire nodes to a blank MetaRig to gain some of the support
features of the codebase without having to manually build a structured network</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to wire as controllers to the MetaRig</li>
<li><strong>name</strong> – name of the MetaRig node generated if no mRig was passed in.</li>
<li><strong>mRig</strong> – optional MetaRig instance to add the controls too,
if blank then we generate a new instance and return that</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.wire_SRC_basefile">
<code class="descname">wire_SRC_basefile</code><span class="sig-paren">(</span><em>name=None</em>, <em>prompt=False</em>, <em>exportRoot=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.wire_SRC_basefile" title="Permalink to this definition">¶</a></dt>
<dd><p>wire an SRC base client file to an SCR_Extension node and hook up the exporter</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.add_fkik_matchpnt">
<code class="descname">add_fkik_matchpnt</code><span class="sig-paren">(</span><em>mSystem</em>, <em>ctrl_wire</em>, <em>fk_wire</em>, <em>matchid</em>, <em>prefix=None</em>, <em>parent=None</em>, <em>target='IK'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.add_fkik_matchpnt" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an ik_match_pnt node into the given mSystem, this parents a new matchpnt transform
to the given fk_wire controller thats aligned to the IK controller requiring snapping
during the fk_to_fk_match call</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mSystem</strong> – mSystem to wire the matchpnt too</li>
<li><strong>ctrl_wire</strong> – mSystem.attr wire connecting the controller to the mSystem, OR the controller object itself - wired to a MetaRigSubSystem
note that this now also supports ctrl_wire attrs that are connected to the SupportNode also</li>
<li><strong>fk_wire</strong> – mSystem.attr wire connecting the fk_jnt to the mSystem, OR object to use directly</li>
<li><strong>matchid</strong> – denotes the matchpnts base wire name - eg : “end”, “pole” creating attr wire ‘mSystem.SupportNode.IK_matchpnt_pole’</li>
<li><strong>prefix</strong> – usually just the side id for the system ‘L’,’R’,’C’, if not given we ID this from the system mirrorSide</li>
<li><strong>parent</strong> – if given this becomes the parent for the matchpnt, else we parent it to the given fk_wrie node</li>
<li><strong>target</strong> – <p>‘IK’ or ‘FK’, reverses the logic of the func. ‘SOLIK’ &amp; ‘SOLFK’ are also now support in the new cache ikfk matching</p>
<ul>
<li>’IK’ the matchpnt is parented under the fk / fk_wire node, and used when snapping to IK mode : the IK ctrl snaps to the FK ctrl</li>
<li>’FK’ the matchpnt is parented under the ik / ctrl_wire node, and used when snapping to FK mode : the FK ctrl snaps to the IK ctrl</li>
<li>’SOLIK’ the matchpnt is parented under the fk / fk_wire node BUT we’re expecting that node to be an end SOL chain node not part of the actual fk system</li>
<li>’SOLFK’ the matchpnt is parented under the ik / ctrl_wire node BUT we’re expecting that node to be an end SOL chain node not part of the actual ik system</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>r9pmeta.add_fkik_matchpnt(mSystem, ctrl_wire=’CTRL_Wrist’, fk_wire=’CTRL_FK_End’, matchid=’end’, prefix=’L’)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>the matchid is actually used to order the snap function and determine what node gets snapped in what order, base id’s</p>
<ul class="last simple">
<li><strong>ik_matchpnt_order</strong> :  [‘toe’, ‘ball’, ‘pole’, ‘mid’, ‘end’, ‘ankle’, ‘start’, ‘hip’, ‘clav’]  =  order in which the matchpnts are processed (reversed)</li>
<li><strong>fk_matchpnt_order</strong> :  [‘toe’, ‘ball’, ‘end’, ‘ankle’, ‘pole’, ‘start’, ‘hip’, ‘clav’] =  order in which the matchpnts are processed (reversed)</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.wire_fkik_matchpoints">
<code class="descname">wire_fkik_matchpoints</code><span class="sig-paren">(</span><em>mrig</em>, <em>force_version=1.08</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.wire_fkik_matchpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>patch to add in ik matchpnts for the ik&gt;fk matching setups</p>
<p>This is exposed for Clients wanting to patch NON Red9 Puppet based systems
but requires each system to have mSystem.SupportNode.GRP_IK_chain, GRP_FK_chain as
wires to denote the group directly above the Ik and Fk chains in the system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mrig</strong> – the mrig instantiated class to process</li>
<li><strong>force_version</strong> – if given this forces the build version of the rig to be ignored. Some of the matchpnt logic
has been clamped to specific build versions for consistency. v1.08 and above triggers the latest logic</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">to run correctly each chain must have the same hierarchy order else the fk
match will be out of sync. Ideally this is to be run as part of a Red9 Patch
system and requires a little baby sitting!</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if the rig is NOT facing the ‘Z’ axis the toe matching data sent to the toe system during the
ik/fk match will be INCORRECT!</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this is NO longer run with PuppetRig, the code deals with the adding of the nodes internally now</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.get_Red9ProductionRig">
<code class="descname">get_Red9ProductionRig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.get_Red9ProductionRig" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to specifically return instances of the ProMeta body Rig for
clients running our rigging systems</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.get_Red9ProductionFacialUI">
<code class="descname">get_Red9ProductionFacialUI</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.get_Red9ProductionFacialUI" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to specifically return instances of the ProMeta facial GUI, be that our internal
production board, or an external board connected to the node such as 3Laterals</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.get_ExportTags">
<code class="descname">get_ExportTags</code><span class="sig-paren">(</span><em>tagIDs=[]</em>, <em>exactmatch=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.get_ExportTags" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to return all ExportTags in the scene with optional filtering by tagID</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tagIDs</strong> – [] if given only return exportTags whos id matches</li>
<li><strong>exactmatch</strong> – bool, if True we name the exact string passed in, else we do ‘if x in y’ : default=False</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.get_ExportLoops">
<code class="descname">get_ExportLoops</code><span class="sig-paren">(</span><em>loopnames=[]</em>, <em>exactmatch=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.get_ExportLoops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to return all ExportLoopNodes in the scene with optional filtering by loopname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>loopname</strong> – [] if given only return ExportLoops whos loopname matches</li>
<li><strong>exactmatch</strong> – bool, if True we name the exact string passed in, else we do ‘if x in y’ : default=False</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.get_fileProductionType">
<code class="descname">get_fileProductionType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.get_fileProductionType" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the status of the currently loaded file depending on the systems found</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">‘SRC_EXT’,’RIG’,’PUB’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.save_connection_datamap">
<code class="descname">save_connection_datamap</code><span class="sig-paren">(</span><em>filepath=None</em>, <em>mrig=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.save_connection_datamap" title="Permalink to this definition">¶</a></dt>
<dd><p>save method to store a complete datamap for the given mRig systems.
This enables us to save an mRig system off to file and reload all wires back without
having to craft custom wiring macro’s directly. This is called in the RigPublisher
to enable you to manually craft rigs and load / save them back in</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – filepath to save the datamap to, if not given prompt</li>
<li><strong>mrig</strong> – save specific mRig in the scene or just find the first instance available</li>
<li><strong>verbose</strong> – if True raise confirmDialog as needed</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.load_connection_datamap">
<code class="descname">load_connection_datamap</code><span class="sig-paren">(</span><em>filepath=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.load_connection_datamap" title="Permalink to this definition">¶</a></dt>
<dd><p>load method to re-construct a datamap from scratch. This enables us to save an mRig
off to file and reload all wires back without having to craft custom wiring macro’s</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – filepath to load the datamap from, if not given prompt</li>
<li><strong>verbose</strong> – if True raise confirmDialog as needed</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.compare_connection_datamap">
<code class="descname">compare_connection_datamap</code><span class="sig-paren">(</span><em>filepath=None</em>, <em>mrig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.compare_connection_datamap" title="Permalink to this definition">¶</a></dt>
<dd><p>compare wrapper method to test a complete datamap for the given mRig systems
against a previously stored out datamap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – filepath to save the datamap to, if not given prompt</li>
<li><strong>mrig</strong> – save specific mRig in the scene or just find the first instance available</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base">
<em class="property">class </em><code class="descname">Pro_MetaRig_Base</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../red9core_templates/Red9_Meta.html#Red9.core.Red9_Meta.MetaRig" title="Red9.core.Red9_Meta.MetaRig"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaRig</span></code></a></p>
<p>Red9 Puppet Rig bespoke Base Class for Rig system MetaRig core, this is a general
extension to the default MetaRig to include systems such as the export handling.
This is aimed to be used for simple bespoke rigs and to provide a new base set of
functions for the main rig and facial classes that inherit from it.</p>
<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.settings">
<code class="descname">settings</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>bound r9Core.FilterSettings object used by the Animation Systems
from now on so that this data can be bound directly to the
rig so we don’t have to use the preset config’s all the time</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_systems">
<code class="descname">get_systems</code><span class="sig-paren">(</span><em>systems</em>, <em>singular=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_systems" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the mRig includes the given systems, and if so, return
those mNode. Note this checks the mRig.getChildren(cAttrs=systems) hook
not the systemType. For that use the get_systems_by_type call</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>systems</strong> – list of simple keys to the systems you’re looking for</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.has_systems">
<code class="descname">has_systems</code><span class="sig-paren">(</span><em>systems</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.has_systems" title="Permalink to this definition">¶</a></dt>
<dd><p>similar to the get_systems method but returns a bool</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>systems</strong> – list of systems we’re checking for</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_connection_datamap">
<code class="descname">get_connection_datamap</code><span class="sig-paren">(</span><em>filepath=''</em>, <em>compare=False</em>, <em>infoblock=True</em>, <em>ctrl_only=True</em>, <em>mInstances=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_connection_datamap" title="Permalink to this definition">¶</a></dt>
<dd><p>return a datamap that holds all connected mSystems and all nodes / attrs wired to this mRig instance,
this is for debugging enabling us to compare that we have matching connections between 2 systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filepath</strong> – if given and not compare=True then we write the datamap to this json filepath.
The existence of the filepath also forces the encode_objects flags on in all of the gatherInfo() calls
ensuring that the data is suitable to file out to json</li>
<li><strong>compare</strong> – if True and filepath is given then we compare the current data extracted with that of
the master file given and return a dict of mismatching data</li>
<li><strong>infoblock</strong> – if True we run gatherInfo() on the mRig to propagate the [info] block with relevant build and meta info</li>
<li><strong>ctrl_only</strong> – if True (default) we ONLY collect data about CTRL_Prefix wired nodes, else we build up a
complete map of all connections to the mRig and it’s child subsystems. Note that when doing a compare against a file
written by the RigManager this should be set to False!!</li>
<li><strong>mInstances</strong> – if given only examine mNode’s inherited from these mInstances</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>this does NOT store any connections to HIK systems, even if wired as HIK mNodes due to the connections complexity of HIK.</li>
<li>compare does NOT compare the actual nodes wired, only the mNode wiring and attrs are currently checked</li>
<li>when running a compare make sure the state of the ctrl_only flag matches between the file version and the state of this key here!!</li>
</ul>
</div>
<p>TODO: currently the main keys are the mNodeID but if we have 2 mNodes with the same mNodeID then we over-write the key,
do we switch the code so that the key is the mNode name to by-pas this?</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.rename_attr_prefix">
<code class="descname">rename_attr_prefix</code><span class="sig-paren">(</span><em>currentPrefix</em>, <em>newPrefix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.rename_attr_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>rename a current mRigs.CTRL_Prefix wires to bring them in line with this
subclass. Case in point, we’ve converted a current mClass to a new class but the
new one has a different self.CTRL_Prefix than the last, resulting in getChildren failing,
this will help sort that issue out</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>currentPrefix</strong> – the current prefix we’re wanting to replace</li>
<li><strong>newPrefix</strong> – default is None which will use this instances self.CTRL_Prefix</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.is_bound">
<code class="descname">is_bound</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.is_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>check to see if this rig is on a live binder</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_bound_root">
<code class="descname">get_bound_root</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_bound_root" title="Permalink to this definition">¶</a></dt>
<dd><p>return the bound root skeleton used by the PRO_to_BND anim transfer systems</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.visibility_renderMeshes">
<code class="descname">visibility_renderMeshes</code><span class="sig-paren">(</span><em>state=True</em>, <em>query=False</em>, <em>toggle=False</em>, <em>mode=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.visibility_renderMeshes" title="Permalink to this definition">¶</a></dt>
<dd><p>if self.renderMeshes is connected then switch the visibility state of
the linked geo</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> – switch state</li>
<li><strong>query</strong> – query the current state of the renderMeshes visibility, not required in toggle or query mode</li>
<li><strong>toggle</strong> – toggle the state of the visibility, overwriting any state passed in</li>
<li><strong>mode</strong> – specific attr that we want to switch, this by-passes the attr checks, supported: ‘visibility’, ‘lodVisibility’, ‘overrideVisibility’
if none is given the code will find the first unlocked, unwired visibility mode from the supported list, in that order of preference</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.visibility_grpmain">
<code class="descname">visibility_grpmain</code><span class="sig-paren">(</span><em>state=True</em>, <em>query=False</em>, <em>toggle=False</em>, <em>mode=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.visibility_grpmain" title="Permalink to this definition">¶</a></dt>
<dd><p>if self.GRP_Main is set then switch the visibility state of
the linked GRP_Main Grp node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> – switch state</li>
<li><strong>query</strong> – query the current state of the grpmain visibility</li>
<li><strong>toggle</strong> – toggle the state of the visibility, overwriting any state passed in</li>
<li><strong>mode</strong> – specific attr that we want to switch, this by-passes the attr checks, supported: ‘visibility’, ‘lodVisibility’, ‘overrideVisibility’
if none is given the code will find the first unlocked, unwired visibility mode from the supported list, in that order of preference</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_meshes_grp">
<code class="descname">get_meshes_grp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_meshes_grp" title="Permalink to this definition">¶</a></dt>
<dd><p>from all the renderMesh wires try and find the top level grp that they’re all under</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_export_meshes">
<code class="descname">get_export_meshes</code><span class="sig-paren">(</span><em>walk=False</em>, <em>select=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_export_meshes" title="Permalink to this definition">¶</a></dt>
<dd><p>new handler to return meshes for export handling, this is to make it
easier to replace all of the renderMeshes logic with the new expTag.exportMeshes wires.
Note that if this is set to walk=True then all subsystems, and you have a child facial mSystem with
it’s own renderMeshes wired, these will also get picked up.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>walk</strong> – False by default, walk all child mSubsystem rigs and include all of their connected
mesh nodes. If False we clamp the return to just those nodes wired to this mRig instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_root_jnt">
<code class="descname">get_root_jnt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.get_root_jnt" title="Permalink to this definition">¶</a></dt>
<dd><p>generic wrapper for some of the healthTests. This should be a reliable and consistent
way to get the skeletonRoot jnt back from any rig system. This is here to handle simple
mSRC style rigs that purely have an exportTag to ID the root jnt.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.addExportTag">
<code class="descname">addExportTag</code><span class="sig-paren">(</span><em>tagID=None</em>, <em>exportClass=None</em>, <em>exportRoot=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.addExportTag" title="Permalink to this definition">¶</a></dt>
<dd><p>add an export tag of  a given type to the rig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tag</strong> – ID of the tag as a string</li>
<li><strong>exportClass</strong> – class of exportTag to link up, this can be a string or the actual class</li>
<li><strong>exportRoot</strong> – the root joint for the export</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.getExportTags">
<code class="descname">getExportTags</code><span class="sig-paren">(</span><em>exportClass=None</em>, <em>singular=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.getExportTags" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all bound exportTags in this system. Usually we’d only expect a single exportTag
per mRig however, in the case of Facial we could have a separate, yet child exportTag 
connected the child mFacial rig, designed to only output that facial data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>exportClass</strong> – if given only search for exportClass of type else return all connected exportTags</li>
<li><strong>singular</strong> – if True we clamp this to the exportTag wire from self rather than any network searching</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.load_pickerTemplate">
<code class="descname">load_pickerTemplate</code><span class="sig-paren">(</span><em>filepath</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.load_pickerTemplate" title="Permalink to this definition">¶</a></dt>
<dd><p>load and bind a given characterPicker template file to the rig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filepath</strong> – cpicker template file to load to the rig</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.trax_makeclip">
<code class="descname">trax_makeclip</code><span class="sig-paren">(</span><em>clipname=''</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.trax_makeclip" title="Permalink to this definition">¶</a></dt>
<dd><p>make a TraxEditor clip from the current anim data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>clipname</strong> – if given this is the name of the clip generated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.bake_rig">
<code class="descname">bake_rig</code><span class="sig-paren">(</span><em>selected=False</em>, <em>runFilter=True</em>, <em>deleteStatics=False</em>, <em>sampleby=1</em>, <em>ignoreInFilter=[]</em>, <em>debugView=False</em>, <em>sparseBake=True</em>, <em>timerange=()</em>, <em>whole_start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.bake_rig" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a generic bake call for the rig controllers - mainly used in conjunction with the Red9 Binder setup but by no means tied to it.
This call will bake all animation down to the rig and remove the Binder system hooks if found. It also manages AnimLayer removal during the bake,
removing a controller from all animation layers if it can do so and should any animLayer become empty, we delete them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>selected</strong> – bake only the selected ctrls if True, else bake all children of this mRig class</li>
<li><strong>runFilter</strong> – if True run a Euler filter on the baked rotate data</li>
<li><strong>deleteStatics</strong> – if True delete static anim curves created, reducing the data set  : changed 25/02/20 now defaults to False</li>
<li><strong>sampleby</strong> – bake frame step, default=1</li>
<li><strong>ignoreFilter</strong> – [] a list of nodes to skip the curve filter post bake if given</li>
<li><strong>debugView</strong> – if True we allow the Maya UI to refresh each frame, else we suspend update</li>
<li><strong>sparseBake</strong> – turns on the sparseAnimCurveBake flag in the bakeResults call, True by default</li>
<li><strong>timerange</strong> – (start, end) optional timerange to bake, by default this uses the standard Red9 timeLineRangeGet func</li>
<li><strong>whole_start</strong> – if True (default) we clamp tyhe start frame to a whole number, corrects for issues with scenes having frames at subframe times</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.preview_camera_get">
<code class="descname">preview_camera_get</code><span class="sig-paren">(</span><em>grp=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.preview_camera_get" title="Permalink to this definition">¶</a></dt>
<dd><p>return the preview camera top group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>grp</strong> – default:True, if True we return the “playblast_camera” top grp, else we return the actual camera transform</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.preview_camera_create">
<code class="descname">preview_camera_create</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.preview_camera_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create the preview camera setup. This is a light wrap over the internal playblast
camera handlers to expose the functionality to users, and to the DAG menus so
animators get access to the same internal camera</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.preview_camera_delete">
<code class="descname">preview_camera_delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.preview_camera_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>simple delete the preview camera setup</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.preview_camera_view">
<code class="descname">preview_camera_view</code><span class="sig-paren">(</span><em>toggle=True</em>, <em>toggleview=False</em>, <em>view=None</em>, <em>lookthrough=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.preview_camera_view" title="Permalink to this definition">¶</a></dt>
<dd><p>toggle / manage the camera view angle</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>toggle</strong> – add 90degrees to the current camera so we rotate around the character</li>
<li><strong>view</strong> – the specific view we’re wanting, ‘front’,’left’,’right’,’back’,’top’,’bottom’</li>
<li><strong>toggleview</strong> – this toggles through the available views</li>
<li><strong>lookthrough</strong> – if True (default) we also set the camera to be the current one in the ‘Persp View’</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.toggle_controller_proximity">
<code class="descname">toggle_controller_proximity</code><span class="sig-paren">(</span><em>state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.toggle_controller_proximity" title="Permalink to this definition">¶</a></dt>
<dd><p>new toggle mode for the Maya controller visibility proximity setups</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_validate">
<code class="descname">animMap_validate</code><span class="sig-paren">(</span><em>filepath=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the internal animCache created by the r9Anim load and stored to
self.animCache. If filepath is given this will load the animCache from file
so we can use the data outside of the loadAnimation call</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filepath</strong> – path to the r9Anim file, if not given then we use the current instance
self.animCache, assuming that we’ve already loaded or processed an r9Anim file on this mRig</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_restore_export_data">
<code class="descname">animMap_restore_export_data</code><span class="sig-paren">(</span><em>extractBy</em>, <em>suppress=False</em>, <em>filepath=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_restore_export_data" title="Permalink to this definition">¶</a></dt>
<dd><p>separate r9Anim / animCache handler to process and restore the export data block in an r9Anim file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>extractBy</strong> – <p>method by which we match up the stored exportLoops and find the ones we want to restore:</p>
<ul>
<li><strong>False</strong> : don’t restore any exportData,</li>
<li><strong>[]</strong> : if you pass in a list then we take that list and match internal exportloop names to it</li>
<li><strong>’byName’</strong> : restore only exportLoops who name matches the r9Anim’s name</li>
<li><strong>’byRange’</strong>: restore exportLoops that fall within the timerange of the imported r9Anim</li>
<li><strong>’byRange_start’</strong> : restore exportLoops that start after the timerange of the importer r9Anim (ignore end time data)</li>
<li><strong>’byRange_end’</strong> : restore exportLoops that end before the timerange of the importer r9Anim (ignore start time data)</li>
<li><strong>’byAll’</strong> : restore ALL exportLoops in the r9Anim infoData block</li>
</ul>
</li>
<li><strong>suppress</strong> – suppress the confirm dialogs</li>
<li><strong>filepath</strong> – path to the r9Anim file, if not given then we use the current instance
self.animCache, assuming that we’ve already loaded or processed an r9Anim file on this mRig</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">Red9.core.Red9_Meta</span> <span class="k">as</span> <span class="nn">r9Meta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">=</span><span class="n">r9Meta</span><span class="o">.</span><span class="n">getMetaRigs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">animMap_restore_export_data</span><span class="p">(</span><span class="n">extractBy</span><span class="o">=</span><span class="s1">&#39;byRange&#39;</span><span class="p">,</span><span class="n">filepath</span><span class="o">=</span><span class="s1">&#39;X:/my_animation_data/walk_to_sit.r9anim&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_restore_audio_data">
<code class="descname">animMap_restore_audio_data</code><span class="sig-paren">(</span><em>extractBy</em>, <em>suppress=False</em>, <em>filepath=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_restore_audio_data" title="Permalink to this definition">¶</a></dt>
<dd><p>separate r9Anim / animCache handler to process and restore the audioGrp data block in an r9Anim file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>extractBy</strong> – <p>method by which we match up the stored exportLoops and find the ones we want to restore:</p>
<ul>
<li><strong>False</strong> : don’t restore any audioData,</li>
<li><strong>[]</strong> : if you pass in a list then we take that list and match internal audioNode names to it</li>
<li><strong>’byName’</strong> : restore only audioNodes who name matches the r9Anim’s name</li>
<li><strong>’byRange’</strong> : restore audioNodes that fall within the timerange of the imported r9Anim</li>
<li><strong>’byRange_start’</strong> : restore audioNodes that start after the timerange of the importer r9Anim (ignore end time data)</li>
<li><strong>’byRange_end’</strong> : restore audioNodes that end before the timerange of the importer r9Anim (ignore start time data)</li>
<li><strong>’byAll’</strong> : restore ALL audioNodes in the r9Anim infoData block</li>
</ul>
</li>
<li><strong>suppress</strong> – suppress the confirm dialogs</li>
<li><strong>filepath</strong> – path to the r9Anim file, if not given then we use the current instance
self.animCache, assuming that we’ve already loaded or processed an r9Anim file on this mRig</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">Red9.core.Red9_Meta</span> <span class="k">as</span> <span class="nn">r9Meta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">=</span><span class="n">r9Meta</span><span class="o">.</span><span class="n">getMetaRigs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">animMap_restore_audio_data</span><span class="p">(</span><span class="n">extractBy</span><span class="o">=</span><span class="s1">&#39;byRange_start&#39;</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s1">&#39;X:/my_animation_data/walk_to_sit.r9anim&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">because the restoration system relies on the AudioGroup mNode and that in turn relies on the ExportTag systems ONLY
mRigs with a valid exportTag will accept Audio restored data via this call</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_restore_talkback_data">
<code class="descname">animMap_restore_talkback_data</code><span class="sig-paren">(</span><em>filepath=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_restore_talkback_data" title="Permalink to this definition">¶</a></dt>
<dd><p>simply parse the r9Anim file and load the animCache dict that will include the
TalkBack data under the audio keys. This will only pull the first audioNode’s data
if there are multiple audioNodes under the audioGrp</p>
<p>animCache.infoDict[‘audioGrp’][‘audioNodes’][audio][‘talkback’]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filepath</strong> – path to the r9Anim file, if not given then we use the current instance
self.animCache, assuming that we’ve already loaded or processed an r9Anim file on this mRig</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_restore_imageplane_data">
<code class="descname">animMap_restore_imageplane_data</code><span class="sig-paren">(</span><em>filepath=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_restore_imageplane_data" title="Permalink to this definition">¶</a></dt>
<dd><p>simply parse the r9Anim file and load the animCache dict that will include the
imageplane data under the facialUI keys. This will only be valid when called from
Pro_MetaRig_FacialUI class objects, or inherited sub-classes</p>
<p>animCache.infoDict[‘facialUI’][‘imageplanes’]</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_preprocess">
<code class="descname">animMap_preprocess</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>run custom handling just before the main r9Anim load call happens. This is currently
responsible for processing and re-building the WristLocks data from the infoDict, restoring
any connected objects from the original scene such as weapons prior to the actual animMap.loadAnim call</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_postprocess">
<code class="descname">animMap_postprocess</code><span class="sig-paren">(</span><em>feedback=None</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_postprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>main postProcess call run internally after the mRig.loadAnimation() call
so we can deal with, and expand additional functionality without padding out the main
AnimMap filehandlers. This is responsible for dealing with the re-generation
and persistence of audio nodes and export loops stored in the r9Anim gathered info blocks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>feedback</strong> – the feedback data from the loadAnimations call</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>default kws: <strong>manageExport</strong>: restore the exportLoop data  # False, [list, or, specific, keys], ‘byName’, ‘byRange’, ‘byRange_start’, ‘byRange_end’, ‘byAll’</li>
<li>default kws: <strong>manageAudio</strong>: restore the AudioGrp data # False, [list, or, specific, keys], ‘byName’, ‘byRange’, ‘byRange_start’, ‘byRange_end’, ‘byAll’</li>
<li>default kws: <strong>manageImagePlanes</strong>: restore the ImagePlane data, simple bool</li>
<li>default kws: <strong>suppress</strong>: suppress any warnings</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_merge_animlayers">
<code class="descname">animMap_merge_animlayers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.animMap_merge_animlayers" title="Permalink to this definition">¶</a></dt>
<dd><p>Testing Only: merge all lanimLayers in the scene, assuming that
there’s only 1 mRig in the scene to process</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.poseLoad_blended">
<code class="descname">poseLoad_blended</code><span class="sig-paren">(</span><em>filepath</em>, <em>useFilter=True</em>, <em>matchMethod='stripPrefix'</em>, <em>percentage=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.poseLoad_blended" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to easily be able to dial in poses via the poseBlender slider, this is basically a wrap
over the StudioPack AnimatioUtils call for the pose blending but setup for the mNodes directly</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – path to the pose file to load</li>
<li><strong>useFilter</strong> – do we load as hierarchy or selected?</li>
<li><strong>matchmethod</strong> – hard coded at the moment</li>
<li><strong>percentage</strong> – if not None them we pass this percentage directly into the load call, by-passing the slider ui</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.switch_attr_compensated">
<code class="descname">switch_attr_compensated</code><span class="sig-paren">(</span><em>node=None</em>, <em>attr=None</em>, <em>val=None</em>, <em>multinode=[]</em>, <em>nodes_to_compensate=[]</em>, <em>mSystems_to_compensate=[]</em>, <em>time=True</em>, <em>timerange=()</em>, <em>keyswitch=True</em>, <em>step=1</em>, <em>smartbake=False</em>, <em>smartbake_ref=[]</em>, <em>padtime=True</em>, <em>runfilter=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.switch_attr_compensated" title="Permalink to this definition">¶</a></dt>
<dd><p>complex func that uses the new exposure of the animPPC handlers to set an attr on a
node / list of nodes without it affecting the world space transforms of those nodes in the <em>‘nodes_to_compensate’</em>
list, if this isn’t given then the entire rig will be compensated for</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – the node holding the attribute we want to switch</li>
<li><strong>attr</strong> – the attribute to switch</li>
<li><strong>val</strong> – the new value for the attribute</li>
<li><strong>multinode</strong> – if given this replaces the node, attr, val flags with a list of tuples such that [(node, attr, val),…]
this allows for more nodes to be processed in 1 go, allowing multiple node attr values to change and be compensated for at the same time</li>
<li><strong>nodes_to_compensate</strong> – a list of controllers that we want to have their world xforms
re-calculated for to compensate for the switched attr</li>
<li><strong>mSystems_to_compensate</strong> – a list of mSystems who’s children we want to have their world xforms
re-calculated for to compensate for the switched attr. These children are added to the nodes_to_compensate list if given</li>
<li><strong>time</strong> – bool, do we compensate the nodes over time or at the curentTime only. if keyswitch=False this is turned off</li>
<li><strong>timerange</strong> – timerange to process, if not given and time=True then we run the r9Anim.timeLineRangeGet() to resolve it
if keyswitch=False this is turned off</li>
<li><strong>keyswitch</strong> – do we set keys on the switch attr and the nodes_to_compensate, or just switch the data without setting any keys</li>
<li><strong>step</strong> – frame step between compensation keys</li>
<li><strong>smartbake</strong> – if True we look at the mSystem’s current keys and only match over those keys if time enabled</li>
<li><strong>smartbake_ref</strong> – if smartbake=True if given, used as reference nodes to extract keytimes from, else we look at all nodes about to be
processed which isn’t always what we want. If we still find no keytimes we revert to base range times with step given</li>
<li><strong>padtime</strong> – if True we pad the timerange processed for the “nodes_to_compensate” by 1 frame either side to allow for solid switching and
compensation, aimed at situations like parent switching where we need solid holding keys outside of the timerange we’re processing</li>
<li><strong>runfilter</strong> – run a quick Euler filter after the process to try and avoid any introduced gimbal</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: expose this as a generic func in r9panim module</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.anim_point_cloud_create">
<code class="descname">anim_point_cloud_create</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>mSystems=[]</em>, <em>time=True</em>, <em>timerange=()</em>, <em>rootReference=None</em>, <em>isVisible=False</em>, <em>step=1</em>, <em>smartbake=False</em>, <em>smartbake_ref=[]</em>, <em>snapScales=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.anim_point_cloud_create" title="Permalink to this definition">¶</a></dt>
<dd><p>cache the anim data to an animPPC node. This relies on there being a properly
setup self.settings (filterSettings) cache on the mRig.mNode itself.
See the self.settings property as to how to set this up</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – if given we only create the cloud against those nodes, else we cache the rigs snapPriorities list</li>
<li><strong>mSystems</strong> – [] list of mSystem nodes who’s children we’ll add to the nodes list for processing</li>
<li><strong>time</strong> – if True then the code resolves the data to an animPPC, caching the motions data
if False it reverts to a static r9PosePPC and only caches the data at the currentTime</li>
<li><strong>timerange</strong> – time to cache, if not given and time=True then we run the r9Anim.timeLineRangeGet() to resolve it</li>
<li><strong>rootReference</strong> – the node used for the initial pivot location and whos motion the reference curves are generated against</li>
<li><strong>isVisible</strong> – do we build all the visual reference curves or not?</li>
<li><strong>step</strong> – frame step between keys if time=True</li>
<li><strong>smartbake</strong> – if True we look at the mSystem’s current keys and only match over those keys if time enabled</li>
<li><strong>smartbake_ref</strong> – if smartbake=True if given, used as reference nodes to extract keytimes from, else we look at all nodes about to be
processed which isn’t always what we want. If we still find no keytimes we revert to base range times with step given</li>
<li><strong>snapScales</strong> – also process the local scale information</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get the main metaRig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">getMetaRigs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create the reference animPPC system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">anim_point_cloud_create</span><span class="p">(</span><span class="n">isVisible</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># adjust the reference PointCloud and when you want to commit back to the mRig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">anim_point_cloud_apply</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.anim_point_cloud_apply">
<code class="descname">anim_point_cloud_apply</code><span class="sig-paren">(</span><em>timerange=()</em>, <em>delete=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.anim_point_cloud_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the anim data from a current animPPC node. This relies on there being a properly
setup self.settings (filterSettings) cache on the mRig.mNode itself.
See the self.settings property as to how to set this up</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>delete</strong> – delete the animPPC nodes after being applied</li>
<li><strong>timerange</strong> – if given this is the timerange to restore from the cache, if not given we run the r9Anim.timeLineRangeGet() to resolve it</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this pulls the animPPC node directly from the current PPC instance in the scene, NOT against
any instance stored on this mNode instance. Because the PPC node caches the class it was generated
from we don’t need to throw the “time” flag like we do in the create call</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.anim_point_cloud_delete">
<code class="descname">anim_point_cloud_delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.anim_point_cloud_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete anim existing animPPC nodes, this is only really for custom use as it’s
managed by the apply call by default</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyAnimation">
<code class="descname">copyAnimation</code><span class="sig-paren">(</span><em>mRig</em>, <em>incRoots=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyAnimation" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the animation data from self onto the given destination mRig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mRig</strong> – destination mRig to copy the animation data over too</li>
<li><strong>incRoots</strong> – usual flag to include the CTRL_Main controller in the copy</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyPose">
<code class="descname">copyPose</code><span class="sig-paren">(</span><em>mRig</em>, <em>incRoots=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the pose data from self onto the given destination mRig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mRig</strong> – destination mRig to copy the animation data over too</li>
<li><strong>incRoots</strong> – usual flag to include the CTRL_Main controller in the copy</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyExportLoops">
<code class="descname">copyExportLoops</code><span class="sig-paren">(</span><em>mRig</em>, <em>loops=[]</em>, <em>loopnames=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyExportLoops" title="Permalink to this definition">¶</a></dt>
<dd><p>copy all exportLoop nodes from self to given mRig system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mRig</strong> – destination mRig to copy the animation data over too</li>
<li><strong>loops</strong> – optional specific loops to copy, else we copy all loops found</li>
<li><strong>loopnames</strong> – if not loops then this becomes a filter to find loops with specific names</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyTimecode">
<code class="descname">copyTimecode</code><span class="sig-paren">(</span><em>mrigs</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyTimecode" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the current timecode from this rig over to the given mRigs</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.castAudioGrp">
<code class="descname">castAudioGrp</code><span class="sig-paren">(</span><em>mRig</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.castAudioGrp" title="Permalink to this definition">¶</a></dt>
<dd><p>connect any instance of an AudioGrp node from this mRig over to the given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mRig</strong> – destination mRig to copy the animation data over too</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyFacial">
<code class="descname">copyFacial</code><span class="sig-paren">(</span><em>mRig</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyFacial" title="Permalink to this definition">¶</a></dt>
<dd><p>copy any linked facial data between any connected facial mRig nodes
bound to the given mRig.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the facial controls are wired to different attr prefixes they don’t, by default,
copy over as facial is treated as an isolated mrig is it’s own right. IF self in this instance
is already a FacialRig then you’d just use the standard copyAnimation call, you wouldn’t need
this extra layer of management</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyData_to_rig">
<code class="descname">copyData_to_rig</code><span class="sig-paren">(</span><em>mRig</em>, <em>animation=True</em>, <em>exportData=True</em>, <em>audioGrp=True</em>, <em>refEdits=True</em>, <em>facialRig=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.copyData_to_rig" title="Permalink to this definition">¶</a></dt>
<dd><p>cast all animation data on this mRig over to the given mRig. This is a full on sync of
systems, capable of casting the animation data, all export data, connected audio nodes
and referenceEdits (this is coming soon)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mRig</strong> – the rig to take the animation data over too</li>
<li><strong>animation</strong> – copy the animation data from self to the given mRig</li>
<li><strong>exportData</strong> – copy the exportData data from self to the given mRig</li>
<li><strong>audioGrp</strong> – copy the audioGrp data from self to the given mRig</li>
<li><strong>facialRig</strong> – if self is a subclass of Pro_MetaRig and has a FacialCore (facial mRig) connected
then copy the data between the facial systems also</li>
<li><strong>refEdits</strong> – copy the refEdits data from self to the given mRig
not yet implemented!</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: cast referenced edits to this source rig</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=3</em>, <em>keys=[]</em>, <em>encode_objects=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>collect key info on this rig system, used to pass data into the
r9Anim and r9Pose files as cross-reference</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>level</strong> – <p>0,1,2,3 : the detail into which we gather data in the report</p>
<ul>
<li><strong>0</strong> = just gather data on self</li>
<li><strong>1</strong> = gather data on self and connected subsystems</li>
<li><strong>2</strong> = more granular detail on all systems, exporter goes into timeranges at this level</li>
<li><strong>3</strong> = run everything and gather as much as we can at the mNode level network</li>
<li><strong>4</strong> = including going down to the renderMeshes and inspecting those for shaders, textures, blends etc</li>
</ul>
</li>
<li><strong>keys</strong> – only return specific keys within the gathered data</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.consumeInfo">
<code class="descname">consumeInfo</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.consumeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>from the gatherInfo dict data consume and process key values back to the mRig node</p>
<ul class="simple">
<li>filterPriority</li>
<li>rigType</li>
<li>version</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_exportData">
<code class="descname">info_exportData</code><span class="sig-paren">(</span><em>encode_objects=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_exportData" title="Permalink to this definition">¶</a></dt>
<dd><p>return a dict of all info on the exporter networks including the loops / export paths &amp; roots</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict{}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_texturePaths">
<code class="descname">info_texturePaths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_texturePaths" title="Permalink to this definition">¶</a></dt>
<dd><p>return list of all textures bound to this mRig’s renderMeshes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list[]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_shaders">
<code class="descname">info_shaders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_shaders" title="Permalink to this definition">¶</a></dt>
<dd><p>return list of all currently connected shadingEngines from the connected renderMeshes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list[]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_jointCount">
<code class="descname">info_jointCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_jointCount" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current joint count of the bound Skeleton hierarchy
the root of this is found firstly via the exportTags, if these aren’t setup
then the skeletonRoot is found from the exportSkeletonRoot wire to the mRig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_blendShapes">
<code class="descname">info_blendShapes</code><span class="sig-paren">(</span><em>levels=4</em>, <em>inc_headmeshes=True</em>, <em>sort_by_count=True</em>, <em>for_export=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_blendShapes" title="Permalink to this definition">¶</a></dt>
<dd><p>return list of all blendshapes bound to the connected renderMeshes history
this is used to extract the blendshapes for fbx skeletal export if flagged</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>levels</strong> – default is 4, walk the history of the renderMeshes 4 levels deep to find blendshapes,
previously this was unclamped but now follows the same pattern as the rest of the r9Core blend get funcs</li>
<li><strong>inc_headmeshes</strong> – if the mRig has renderMeshes_head attr and we have meshes wired to that plug
include those in the return. This wire is used primarily by our FacialCore systems</li>
<li><strong>sort_by_count</strong> – sort the returned blendshapes by the number of targets, largest first</li>
<li><strong>for_export</strong> – added so we can clamp the return to either this single mRig instance or the wider
full network and all meshes set for export</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list[]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_blendCount">
<code class="descname">info_blendCount</code><span class="sig-paren">(</span><em>sort_by_count=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_blendCount" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current blendshape count of any blendshapes in the connected renderMeshes history</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sort_by_count</strong> – sort the returned blendshapes by the number of targets, largest first</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_audioGrp">
<code class="descname">info_audioGrp</code><span class="sig-paren">(</span><em>encode_objects=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_audioGrp" title="Permalink to this definition">¶</a></dt>
<dd><p>return all audioGRP info connected to this rig system including connected audioNodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict{}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_timecode">
<code class="descname">info_timecode</code><span class="sig-paren">(</span><em>timerange=()</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.info_timecode" title="Permalink to this definition">¶</a></dt>
<dd><p>return all timecode data for this rig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timerange</strong> – we need to process the Timecode against a start and end time to get the
range of the anim data, if none is passed in then we grab the timeline ranges</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict{}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.parallel_eval_get_nodes">
<code class="descname">parallel_eval_get_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.parallel_eval_get_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>get nodes within the rig that we know to be expensive in computation
so that we can mute these in parallel eval as required for playback speed</p>
<p>this is used primarily when switching systems visibility off such as toggling
the facial rig vis state. In 2016 when a hierarchy is not visibility it IS STILL
being computed by the evalmanager. The parallel_eval_mute call is designed to
freeze the returned nodes of this proc, thus returning that framerate back to the user.</p>
<p>default is to just deal with the renderMeshes</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.parallel_eval_mute">
<code class="descname">parallel_eval_mute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.parallel_eval_mute" title="Permalink to this definition">¶</a></dt>
<dd><p>for everything returned by the “parallel_eval_get_nodes” func set their ‘frozen’
node state to True, this prevents them from being calculated in the evalmanager during parallel eval.</p>
<p>Why? in 2016-17 even if you make a hierarchy invisible it is STILL getting calculated per frame,
unlike the DG eval which would optimize these hidden nodes out. This is optimized in 2018 but
hidden nodes will still have full framerate hit as if they were visible</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.parallel_eval_reset">
<code class="descname">parallel_eval_reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base.parallel_eval_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>for everything returned by the “parallel_eval_get_nodes” func reset their frozen state so they calcualte</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig">
<em class="property">class </em><code class="descname">Pro_MetaRig</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base</span></code></a></p>
<p>This is the Red9 PuppetRigs master base class, However with a little careful
wiring any other external rig system can be wired too and utilise these functions.</p>
<p>Additional internal vars worth noting, these are for clients subclassing or running
their own internal rigs over the Pro_MetaRig networks:</p>
<ul>
<li><p class="first"><strong>self.ik_fk_switchattr</strong> : [] the attribute within the rig controllers that switches the rig between fk and ik mode state [‘ik_fk_blender’]</p>
</li>
<li><p class="first"><strong>self.fk_world_attr</strong> : [] the attributes used within the rig for FK chain world/local orient blending [‘FK_world_orient’]</p>
</li>
<li><p class="first"><strong>self.ik_switch_val</strong> : the value of the above attr when in ik state</p>
</li>
<li><p class="first"><strong>self.fk_switch_val</strong> : the value of the above attr when in fk state</p>
</li>
<li><p class="first"><strong>self._ik_chainmethod</strong> :</p>
<blockquote>
<div><ul class="simple">
<li><strong>‘jnt_index’</strong> - default, straight joint hierarchy from the mSystem.SupportNode.GRP_IK_chain[0] node</li>
<li><strong>‘ctrl_index’</strong> - filtered hierarchy of nurbsCurve from the mSystem.SupportNode.GRP_IK_chain[0] node</li>
<li><strong>‘ik_wires’</strong> - uses the mSystem.SupportNode.IK_** wires to directly extract the ik chain nodes</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>self._fk_chainmethod</strong> :</p>
<blockquote>
<div><ul class="simple">
<li><strong>‘jnt_index’</strong> - default, straight joint hierarchy from the mSystem.SupportNode.GRP_FK_chain[0] node</li>
<li><strong>‘ctrl_index’</strong> - filtered hierarchy of nurbsCurve from the mSystem.SupportNode.GRP_FK_chain[0] node</li>
<li><strong>‘fk_wires’</strong> - uses the mSystem’s CTRL_FK wiring to grab and return the nodes directly (FK_Start, FK_Pole, FK_End)</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>self._ik_matchpnt_order</strong> : * [‘toe’, ‘ball’, ‘pole’, ‘mid’, ‘end’, ‘ankle’, ‘start’, ‘hip’, ‘clav’]  =  order in which the matchpnts are processed (reversed)</p>
</li>
<li><p class="first"><strong>self._fk_matchpnt_order</strong> : * [‘toe’, ‘ball’, ‘end’, ‘ankle’, ‘pole’, ‘start’, ‘hip’, ‘clav’] =  order in which the matchpnts are processed (reversed)</p>
</li>
<li><p class="first"><strong>self._ik_zero_ctrl_attrs</strong> : * [(CTRL_wire, [attrs]), (…] = additional attrs on the given ctrls which need to be set back to         zero during the switch to IK (usually toe, ball_lift etc)</p>
</li>
<li><p class="first"><strong>self.parentSwitchAttr</strong> : [‘parent’] - the pointer to the attr that we use for parentSpace switch management</p>
</li>
<li><p class="first"><strong>self.exportBase_class</strong> : the base export class object that will be created by the addExportTag call, allows custom mNodes to support custom export systems</p>
</li>
<li><p class="first"><strong>self.locomotion_track_pnt</strong> : non-default, additional attr / wire that can be used to denote the node we track in the LocomotionCtrl Tracker</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>self.parentSwitchAttr is a list but we currently only look at the first value for all of the parentSpace switching.
If you’re trying to connect your own rigs to meta and need to change this value you can either subclass Pro_MetaRig
OR you can directly add the attr to the mRig node which will overload the class var. This will be dynamically reflected
in the ParnetSpace UI</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># change the attr we use for parent space management to the new attr &#39;follow&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">getMetaRigs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">addAttr</span><span class="p">(</span><span class="s1">&#39;parentSwitchAttr&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;follow&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>IKFK Management attrs are all also available for customization at the mSystem level. The easiest way to do this is to use
the following call to get the correctly formatted data, then modify it and set it back to a attribute on the mSystem Maya node
itself. This attr will be then used at the mSystem level to control the behaviour of the ikfk switching</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># grab the mSystem we want to change the bindings for</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span> <span class="o">=</span> <span class="n">r9Meta</span><span class="o">.</span><span class="n">getMetaRigs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msystem</span> <span class="o">=</span> <span class="n">mrig</span><span class="o">.</span><span class="n">L_ArmSystem</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># grab the full dict from the class so we can modify it</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mapdata</span> <span class="o">=</span> <span class="n">mrig</span><span class="o">.</span><span class="n">_get_ikfk_switch</span><span class="p">(</span><span class="n">msystem</span><span class="p">,</span> <span class="n">fullmap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set mapdata{} back after changing one of the values to reflect your own rig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">_set_ikfk_switchdata</span><span class="p">(</span><span class="n">msystem</span><span class="p">,</span> <span class="n">mapdata</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># you&#39;ll now see a new attribute on the mSystem Maya node that holds the data moving forwards</span>
</pre></div>
</div>
</div>
<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.Skeleton">
<code class="descname">Skeleton</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.Skeleton" title="Permalink to this definition">¶</a></dt>
<dd><p>INTERNAL RED9 : binding of the skeleton class used by the build code</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=3</em>, <em>keys=[]</em>, <em>encode_objects=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>collect key info on this Red9 Puppet rig system, used to pass data into the
r9Anim and r9Pose files as cross-reference</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>level</strong> – <p>0,1,2,3 : the detail into which we gather data in the report</p>
<ul>
<li><strong>0</strong> = just gather data on self</li>
<li><strong>1</strong> = gather data on self and connected subsystems</li>
<li><strong>2</strong> = more granular detail on all systems, exporter goes into timeranges at this level</li>
<li><strong>3</strong> = run everything and gather as much as we can at the mNode level network</li>
<li><strong>4</strong> = including going down to the renderMeshes and inspecting those for shaders,textures, blends etc</li>
</ul>
</li>
<li><strong>keys</strong> – only return specific keys within the gathered data</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.gather_wrist_lock_data">
<code class="descname">gather_wrist_lock_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.gather_wrist_lock_data" title="Permalink to this definition">¶</a></dt>
<dd><p>generic collection used by the gatherInfo code to collect the plugs used
by the WristLock systems in the ProPack and PuppetRig</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.rebuild_wrist_locks">
<code class="descname">rebuild_wrist_locks</code><span class="sig-paren">(</span><em>wristlock_data</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.rebuild_wrist_locks" title="Permalink to this definition">¶</a></dt>
<dd><p>from a gatherInfo block generated above, rebuild, or attempt to rebuild the
wristlock networks. Used by the r9Anim code for data integrity</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.connect_facial_ui">
<code class="descname">connect_facial_ui</code><span class="sig-paren">(</span><em>facialcore=None</em>, <em>autofind=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.connect_facial_ui" title="Permalink to this definition">¶</a></dt>
<dd><p>connect an instance of the FacialCore to the mRig</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_patches">
<code class="descname">get_patches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_patches" title="Permalink to this definition">¶</a></dt>
<dd><p>return the patch data and print details</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_systems_by_type">
<code class="descname">get_systems_by_type</code><span class="sig-paren">(</span><em>systype</em>, <em>walk=True</em>, <em>stepover=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_systems_by_type" title="Permalink to this definition">¶</a></dt>
<dd><p>get a list of given child Meta Node Systems by type</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>systype</strong> – the system type we’re looking for based on the systemType mAttr on the Red9 Puppet nodes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.visibility_renderMeshes_head">
<code class="descname">visibility_renderMeshes_head</code><span class="sig-paren">(</span><em>state=True</em>, <em>query=False</em>, <em>toggle=False</em>, <em>mode=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.visibility_renderMeshes_head" title="Permalink to this definition">¶</a></dt>
<dd><p>switch off the display of all body_Rig head geo based on the renderMesh_head attr
and if we have a facial rig wired, turn ON it’s renderMesh geo</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> – switch the state of the renderMeshs, not required in toggle or query mode</li>
<li><strong>query</strong> – query the current state</li>
<li><strong>toggle</strong> – toggle the state of the visibility, overwriting any state passed in</li>
<li><strong>mode</strong> – specific attr that we want to switch, this by-passes the attr checks, supported: <em>‘visibility’, ‘lodVisibility’, ‘overrideVisibility’</em>
if none is given the code will find the first unlocked, unwired visibility mode from the supported list, in that order of preference</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.visibility_renderMeshes_static_head">
<code class="descname">visibility_renderMeshes_static_head</code><span class="sig-paren">(</span><em>state=True</em>, <em>query=False</em>, <em>toggle=False</em>, <em>mode=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.visibility_renderMeshes_static_head" title="Permalink to this definition">¶</a></dt>
<dd><p>switch off the display of all body_Rig head geo based on the renderMeshes_static_head attr
and if we have a facial rig wired, turn ON it’s renderMesh geo. This has replaced the 
renderMeshes_head visibility switch as it made no sense having geo which was only
every meant to be visual reference being marked as the head geo.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> – switch the state of the renderMeshs, not required in toggle or query mode</li>
<li><strong>query</strong> – query the current state</li>
<li><strong>toggle</strong> – toggle the state of the visibility, overwriting any state passed in</li>
<li><strong>mode</strong> – specific attr that we want to switch, this by-passes the attr checks, supported: <em>‘visibility’, ‘lodVisibility’, ‘overrideVisibility’</em>
if none is given the code will find the first unlocked, unwired visibility mode from the supported list, in that order of preference</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.visibility_facial">
<code class="descname">visibility_facial</code><span class="sig-paren">(</span><em>state=True</em>, <em>query=False</em>, <em>toggle=False</em>, <em>evalmanaged=True</em>, <em>mode=None</em>, <em>gpu_toggle=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.visibility_facial" title="Permalink to this definition">¶</a></dt>
<dd><p>this function carefully toggles the visible state of a wired facial system, allowing
you to visually switch between fully setup facial meshes and static head meshes.</p>
<p>If the self.FacialCore attr is wired to a facial rig then this function will carefully
toggle that rigs visibility state. For example: if state=True and FacialCore.GRP_Main is
wired then we turn on it’s visibility, we also turn on visibility for meshes wired to
self.renderMeshes_head and finally we turn off those meshes wired to renderMeshes_static_head.
There are also different levels of management depending on how much of our system are wired,
going down to very simple toggling between “renderMeshes_static_head” and “renderMeshes_head”</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> – switch state, True favours the FacialCore’s geo to be visible, not required in toggle or query mode</li>
<li><strong>query</strong> – query the current state of the facial visibility</li>
<li><strong>toggle</strong> – toggle the state of the visibility, overwriting any state passed in</li>
<li><strong>evalmanaged</strong> – if True we also manage the frozen state of all key nodes in the rig to speed up
parallel eval on the hidden rig system</li>
<li><strong>mode</strong> – specific attr that we want to switch, this by-passes the attr checks, supported: ‘visibility’, ‘lodVisibility’, ‘overrideVisibility’
if none is given the code will find the first unlocked, unwired visibility mode from the supported list, in that order of preference</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>self.renderMeshes_head has been elevated and its visibility behaviour inversed. This code deals with
the legacy rigs which will still behave correctly as long as they were published before April 2021.</p>
<p class="last">As of April 2021 we’ve changed this system as we’ve introduced a new wire, “renderMeshes_static_head”
which will now be used to denote those static heads which get switched off when we toggle the facial
system and meshes on. Previously the “renderMeshes_head” was used for this but it clashes in logic as
this wire is also used for the exporter and these static placeholder meshes should never have been taken into account.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_ikfk_state">
<code class="descname">get_ikfk_state</code><span class="sig-paren">(</span><em>system</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_ikfk_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get the ik / fk state of the given mSystem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>system</strong> – mSystem to inspect</td>
</tr>
<tr class="field-even field"><th class="field-name">Return str:</th><td class="field-body">‘fk’ or ‘ik’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.switch_to_fk">
<code class="descname">switch_to_fk</code><span class="sig-paren">(</span><em>mSystems=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.switch_to_fk" title="Permalink to this definition">¶</a></dt>
<dd><p>switch the entire rig or just a given set of mSystems to FK mode (NO MATCHING)
This just throws the defined self.ik_fk_switchattr attr to self.fk_switch_val</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mSystems</strong> – systems to switch mode for</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.switch_to_ik">
<code class="descname">switch_to_ik</code><span class="sig-paren">(</span><em>mSystems=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.switch_to_ik" title="Permalink to this definition">¶</a></dt>
<dd><p>switch the entire rig or just a given set of mSystems to IK mode (NO MATCHING)
This just throws the defined self.ik_fk_switchattr attr to self.ik_switch_val</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mSystems</strong> – systems to switch mode for</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.fk_ik_toggle">
<code class="descname">fk_ik_toggle</code><span class="sig-paren">(</span><em>mSystem</em>, <em>time=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.fk_ik_toggle" title="Permalink to this definition">¶</a></dt>
<dd><p>simple toggle call to switch the current state of the system between fk and ik with matching.
This checks the self.ik_fk_switchattr and if it equals self.fk_switch_val toggles over to FK,
if it equals self.ik_switch_val then we switch to IK.</p>
<p>Used in the DagProcMenu systems</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mSystem</strong> – the mSystem we want to toggle, this expects an instanciated MetaSubSystems
such as mrig.L_ArmSystem</li>
<li><strong>time</strong> – if True we match the systems over the current or selected timerange</li>
<li><strong>verbose</strong> – if True we throw a confirm dialog when dealing with time to make sure this is what the user wanted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.fk_ik_match">
<code class="descname">fk_ik_match</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>mSystems=[]</em>, <em>time=False</em>, <em>switch=False</em>, <em>keyswitch=True</em>, <em>keyctrls=True</em>, <em>ik_chainmethod=None</em>, <em>fk_chainmethod=None</em>, <em>timerange=()</em>, <em>step=1</em>, <em>smartbake=False</em>, <em>smartbake_ref=[]</em>, <em>runfilter=True</em>, <em>autoclav=True</em>, <em>cached_solution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.fk_ik_match" title="Permalink to this definition">¶</a></dt>
<dd><p>&gt; TO FK MODE: Set the given systems, match the FK system to that of the IK</p>
<p>If cached_solution=True the systems change and rather than using the ik_chain data we use the SOL chain via 
the self._get_sol_chain call. The SOL chain is expected to be the end solved chain in the ikfk limb setup,
the result of any ikfk blend states etc. The animation is first cached over time before the match can be done,
this is because the SOL data is assumed to be the end solve of the ikfk system so we can’t just solve directly 
to it as each match would invalidate the animation moving forward. The benefit of this method is that it doesn’t
care of the current state of the system over time, you can have multiple ik fk blends, switching back and forth,
and this method will just “cast” the state of the system to the FK mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – [] hint nodes wired to the systems you want to match, used to find id subSystems to process</li>
<li><strong>mSystems</strong> – [] list of mSystem nodes to switch, if given we don’t process the nodes args</li>
<li><strong>time</strong> – bool, whether to enable the match over time or not, True by default if timerange arg is given</li>
<li><strong>switch</strong> – also switch the ik_fk_blender attr to leave the system in FK mode</li>
<li><strong>keyswitch</strong> – if switch is true, this also adds in keys to control the switch mode</li>
<li><strong>keyctrls</strong> – True by default, this dictates if we key the controllers even when time = False, ie during a static switch</li>
<li><strong>ik_chainmethod</strong> – <p>None by default as controlled by the internal mRig var self._ik_chainmethod
method of extracting the ik joints, currently supported:</p>
<ul>
<li><strong>jnt_index</strong> - default - straight joint hierarchy from the mSystem.SupportNode.GRP_IK_chain[0]</li>
<li><strong>ctrl_index</strong> - filtered hierarchy of nurbsCurve from the mSystem.SupportNode.GRP_IK_chain[0]</li>
<li><strong>ik_wires</strong> - uses the internal mSystem.SupportNode.IK_** wires to directly extract the ik chain nodes.                This is useful if a client has setup a broken hierarchy for the IK systems.                These are processed in the following order [IK_toe, IK_end, IK_pole, IK_start]</li>
</ul>
</li>
<li><strong>fk_chainmethod</strong> – <p>None by default as controlled by the internal mRig var self._fk_chainmethod
method of extracting the fk controls, currently supported:</p>
<ul>
<li><strong>jnt_index</strong> - straight joint hierarchy from the mSystem.SupportNode.GRP_FK_chain[0] node</li>
<li><strong>ctrl_index</strong> - filtered hierarchy of nurbsCurve controllers from the mSystem.SupportNode.GRP_FK_chain[0] node</li>
<li><strong>fk_wires</strong> - uses the mSystem’s CTRL_FK* wiring to grab and return the nodes from the mSystem itself</li>
</ul>
</li>
<li><strong>timerange</strong> – (start, end) if given we force the time switch on and use this as the timerange
rather than auto finding it from the scene</li>
<li><strong>step</strong> – frame step between keys if time=True</li>
<li><strong>smartbake</strong> – if True we look at the mSystem’s current keys and only match over those keys if time enabled</li>
<li><strong>smartbake_ref</strong> – smartbake=True if given, used as reference nodes to extract keytimes from, else we look at all nodes about to be
processed which isn’t always what we want. If we still find no keytimes we revert to base range times with step given</li>
<li><strong>runFilter</strong> – if processing over time run a EulerFilter on the resulting data, primarily added for the smartBake to reduce gimbal between steps</li>
<li><strong>autoclav</strong> – Red9 Puppet only &gt;&gt; if we have an arm system do we compensate its data when switching to FK, baking down any autoClav data</li>
<li><strong>cached_solution</strong> – Red9 PuppetRig only &gt;&gt; rather than simply matching the FK jnts to the IK jnts we cache the final solve of the entire system and use that.
Uses the Solution nodes rather than directly matching the IK system, allows us to force a limb over to FK regardless of any current IK&gt;FK switching going on</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this runs 2 main calls to get a matching set of nodes that are then matched, the return from the following
calls should produce lists that can be matched <strong>self._get_ik_chain, self._get_fk_chain</strong></p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.ik_fk_match">
<code class="descname">ik_fk_match</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.ik_fk_match" title="Permalink to this definition">¶</a></dt>
<dd><p>&gt; TO IK MODE  : Set the given systems, match the IK to the FK system, relies on the IK_matchpnt’s</p>
<p>If cached_solution=True the systems change and rather than using the ik_chain data we use the SOL chain via 
the self._get_sol_chain call. The SOL chain is expected to be the end solved chain in the ikfk limb setup,
the result of any ikfk blend states etc. The animation is first cached over time before the match can be done,
this is because the SOL data is assumed to be the end solve of the ikfk system so we can’t just solve directly 
to it as each match would invalidate the animation moving forward. The benefit of this method is that it doesn’t
care of the current state of the system over time, you can have multiple ik fk blends, switching back and forth,
and this method will just “cast” the state of the system to the IK mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – [] hint nodes wired to the systems you want to match, used to find id subSystems</li>
<li><strong>mSystems</strong> – [] list of mSystem nodes to switch, if given we don’t process the nodes args</li>
<li><strong>time</strong> – bool, whether to enable the match over time or not, True by default if timerange arg is given</li>
<li><strong>switch</strong> – also switch the ik_fk_blender attr to leave the system in IK mode</li>
<li><strong>keyswitch</strong> – if switch is true, this also adds in keys to control the switch mode</li>
<li><strong>keyctrls</strong> – True by default, this dictates if we key the controllers even when time = False, ie during a static switch</li>
<li><strong>timerange</strong> – if given we throw the time switch by default and use this as the time range rather than auto finding it from the scene</li>
<li><strong>step</strong> – frame step between keys if time=True</li>
<li><strong>smartbake</strong> – if True we look at the mSystem’s current keys and only match over those keys if time enabled</li>
<li><strong>smartbake_ref</strong> – smartbake=True if given, used as reference nodes to extract keytimes from, else we look at all nodes about to be
processed which isn’t always what we want. If we still find no keytimes we revert to base range times with step given</li>
<li><strong>runFilter</strong> – if processing over time run a EulerFilter on the resulting data, primarily added for the smartBake to reduce gimbal between steps</li>
<li><strong>vectoredpole</strong> – &lt;&lt; internal testing &gt;&gt;  use the pole alignment vector code rather than just simple track</li>
<li><strong>cached_solution</strong> – Red9 PuppetRig only &gt;&gt; Red9 PuppetRig only &gt;&gt; rather than simply matching the IK ctrls to the FK setup we cache the final solve of the entire system and use that.
Uses the Solution nodes rather than directly matching the FK system, allows us to force a limb over to IK regardless of any current IK&gt;FK switching going on</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">by default this call depends on IK_matchpnt’s which denote the relationship between the
FK and IK controller, these are added by using the “r9pmeta.add_fkik_matchpnt” code.
However these are easy to add to any rig wired to Meta</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if the mSystem itself has a string attr “matchpnt_order=[]” then the process order of the matchpnts follows that (inversed),
else it’s hard coded to process  [‘toe’, ‘ball’, ‘end’, ‘ankle’, ‘pole’, ‘start’, ‘hip’, ‘clav’] (inversed when processed).
This allows clients and custom rigs to denote their own process order for the matching of the ik controllers.
The entries here are the “matchid” args passed to the “add_fkik_matchpnt” func itself when the matchpnts were made, basically
the wire attr that links the matchpnt to the mSupportNode such that the attrs would be “IK_matchpnt_xxxx”</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_fingers_selected">
<code class="descname">get_fingers_selected</code><span class="sig-paren">(</span><em>nodes=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_fingers_selected" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrapper to return the finger markers from selected ctrls
so we know what fingers we have controllers selected from</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">that these finger calls are designed to be called from
the FingerSystem mNode directly not from the upper MetaRig node</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_fingers_chains_selected">
<code class="descname">get_fingers_chains_selected</code><span class="sig-paren">(</span><em>nodes=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.get_fingers_chains_selected" title="Permalink to this definition">¶</a></dt>
<dd><p>return the full finger chains from the selected finger controllers</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">that these finger calls are designed to be called from
the FingerSystem mNode directly not from the upper MetaRig node</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.zero_selected_fingers">
<code class="descname">zero_selected_fingers</code><span class="sig-paren">(</span><em>nodes=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.zero_selected_fingers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig.switch_parent_space">
<code class="descname">switch_parent_space</code><span class="sig-paren">(</span><em>mSystem=[], newspace='', time=False, timerange=(), keyswitch=False, cAttrs=['CTRL_Wrist', 'CTRL_Foot', 'CTRL_Head', 'CTRL_End*'], step=1, smartbake=False, smartbake_ref=[], runfilter=True, switch_nodes=[], *args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig.switch_parent_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch the “parent” space of given nodes whilst compensating their world space transforms.
This originally was clamped to just the Arm / Leg systems, compensating the Wrist / Feet controls, but
with the additional of the “switch_nodes” arg has been expanded to any controller with the rig which
contains the “parent” attr.
This is a wrapper over the more generic <em>“switch_attr_compensated”</em> func in the Pro_MetaRig_Base class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mSystem</strong> – method 1: mSystem or [mSystem, mSystem…] the sub-system/ systems we’re going to switch over,
this now accepts a list of mSystems to process in 1 hit</li>
<li><strong>newspace</strong> – the new parentSpace attribute value to switch and compensate for, this is either an int val as the attr
should be an enum OR it will now take a string which is the string value of that enum. Given as a string means that
it’s dynamically set to the correct index raegardless of the ordder of the enums on each mSystem</li>
<li><strong>time</strong> – bool, do we compensate the nodes over time or at the curentTime only. if keyswitch=False this is turned off</li>
<li><strong>timerange</strong> – timerange to process, if not given and time=True then we run the r9Anim.timeLineRangeGet() internally
to resolve it, if keyswitch=False this is turned off</li>
<li><strong>keyswitch</strong> – do we set keys on the switch attr and the nodes_to_compensate, or just switch the data without setting any keys</li>
<li><strong>cAttrs</strong> – this is passed into the mSystem.getChildren(cAttrs) args to find those nodes that we need to compensate,
this is a list of the mSytstem connections to the controllers NOT the node names or dags</li>
<li><strong>step</strong> – frame step between keys if time=True</li>
<li><strong>smartbake</strong> – if True we look at the mSystem’s current keys and only match over those keys if time enabled</li>
<li><strong>switch_nodes</strong> – [] optional / method2 : list of nodes (full dag paths) that have both the parentSpace enum attr
AND which should be compensated for. This allows us to pass in simple parentSpace switching, such as Prop_Ctrls rather than
relying on the mSystem to find the correct data.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the parent space attr used is managed by the mRig.parentSwitchAttr[0] arg and is expected to be of type ‘enum’</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The way we resolve the data now supports 2 methods:</p>
<ul class="last simple">
<li><strong>Method 1</strong>: original base method : you pass in the mSystem and let the code find the first instance of an object in that system
that has the parentSpace attr, and then resolve what controllers should be compensated for using the cAttrs arg.</li>
<li><strong>Method 2</strong>: new default method : you can simply pass in a ctrl list to the switch_nodes[] args, assuming that each of these controllers
has the parentSpace attr on it and that these are also the ctrls that need to be compensated for. This second method is 
designed for simple structures such as Prop_Ctrls etc. In this second mode we ignore the cAttrs arg</li>
</ul>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Method 1:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">switch_parent_space</span><span class="p">(</span><span class="n">mSystem</span><span class="o">=</span><span class="p">[</span><span class="n">mrig</span><span class="o">.</span><span class="n">L_ArmSystem</span><span class="p">],</span> <span class="n">newspace</span><span class="o">=</span><span class="s1">&#39;Forearm&#39;</span><span class="p">,</span> <span class="n">cAttrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CTRL_Wrist&#39;</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keyswitch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Method 2:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">switch_parent_space</span><span class="p">(</span><span class="n">mSystem</span><span class="o">=</span><span class="p">[],</span> <span class="n">newspace</span><span class="o">=</span><span class="s1">&#39;Forearm&#39;</span><span class="p">,</span> <span class="n">switch_nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Puppet:L_Prop_Ctr&#39;</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keyswitch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC">
<em class="property">class </em><code class="descname">Pro_MetaRig_SRC</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base</span></code></a></p>
<p>Class node used by the publisher systems. With the SRC_RiggingUI you can add into an SRC file
an Pro_MetaRig_SRC node which is designed as a basic, client facing extension to the Red9Puppet.</p>
<p>The SRC file in our definition is the file with the base character, skeleton and skinning plus client
specific controllers in it. By wiring these to the SRC node our Red9 Publishing systems sees the data
and merges it into the main MetaRig on build. This means that client can add in their own subsystems,
manage new controllers and be certain that this data is then merged into the main rig for all the rest
of the pipelines.</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC.isValid">
<code class="descname">isValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC.isValid" title="Permalink to this definition">¶</a></dt>
<dd><p>modify the behaviour as we don’t want to be stripping SRC EXT nodes that easily</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC.grp_main">
<code class="descname">grp_main</code><span class="sig-paren">(</span><em>force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC.grp_main" title="Permalink to this definition">¶</a></dt>
<dd><p>return the grp main group node if force=True and it doesn’t already exist create it</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Prop">
<em class="property">class </em><code class="descname">Pro_MetaRig_Prop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base</span></code></a></p>
<p>MetaRig subclass for Props - binds to the ExportTag_Prop class</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle">
<em class="property">class </em><code class="descname">Pro_MetaRig_Vehicle</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base</span></code></a></p>
<p>MetaRig subclass for Vehicles - binds to the ExportTag_Vehicle class</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.get_front_wheels">
<code class="descname">get_front_wheels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.get_front_wheels" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list, front wheels meta nodes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.get_back_wheels">
<code class="descname">get_back_wheels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.get_back_wheels" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list, front wheels meta nodes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.front_wheel_radius">
<code class="descname">front_wheel_radius</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.front_wheel_radius" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Float, the radius of the front wheel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.Back_wheel_radius">
<code class="descname">Back_wheel_radius</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.Back_wheel_radius" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Float, the radius of the back wheel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.wheels_height">
<code class="descname">wheels_height</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Vehicle.wheels_height" title="Permalink to this definition">¶</a></dt>
<dd><p>The height fom the ground to the center of the wheels, if front and back wheels have different radius
it wheel return an average between back and front wheels
:return: float</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_External">
<em class="property">class </em><code class="descname">Pro_MetaRig_External</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_External" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base</span></code></a></p>
<p>MetaRig subclass - base class for external rigs being wired to the system, 
unless being wired to simulate a Red9 Puppet wiring setup, usually with
support from us directly - binds to the ExportTag_Character class</p>
<p>This is designed to enable base ProPack users to quickly hook
their own rigs to the systems without trying to emulate the
Red9 Puppets complex wiring structures.</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_RigidBody">
<em class="property">class </em><code class="descname">Pro_MetaRig_RigidBody</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_RigidBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base</span></code></a></p>
<p>MetaRig subclass for RigidBody style rigs - binds to the ExportTag_RigidBody class</p>
<p>This is designed to enable base ProPack users to quickly hook
their own rigs to the systems without trying to emulate the
Red9 Puppets complex wiring structures.</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI">
<em class="property">class </em><code class="descname">Pro_MetaRig_FacialUI</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Base</span></code></a></p>
<p>SubClass of the MetaRig, designed to manage facial board style controls
for a facial system. Just an extract class to inherit from but it means that
all our facial logic will find custom class control boards based on being
sub-classed from this consistent base.</p>
<p>Additional key wires expected in a FacialRig to comply with the codebase
these are on-top of the usual controllers connected to the system and the renderMeshes wires to the geo.</p>
<ul class="simple">
<li>self.JNT_FaceRoot : should be wired to the root joint of the facial skeleton, or the head joint if there is no facialRoot joint</li>
<li>self.JNT_Chest : should be wired to the chest joint - used to bind the cameras up</li>
<li>self.GRP_Main : used to mark the top root group in the facial system, used in the visibility management so we can turn the entire setup off</li>
</ul>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>full delete and clean of a rig system and network</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrap to load the zeroPose if found</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.ctrl_locomotion">
<code class="descname">ctrl_locomotion</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.ctrl_locomotion" title="Permalink to this definition">¶</a></dt>
<dd><p>this ensures that the facial rig returns it’s parent BodyRig’s locomotion ctrl
which is required for some of the exporter behaviour. This forces there to  be
a consistent return for all data</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=3</em>, <em>keys=[]</em>, <em>encode_objects=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>info block gather for the facialcore channel values</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_anchor_pnt">
<code class="descname">get_anchor_pnt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_anchor_pnt" title="Permalink to this definition">¶</a></dt>
<dd><p>generic method to extract the relevant node in the FaceRig
that both the face_mesh_cam and the imageplane will use as the
initial snap point. Basically we need a node / jnt in the setup that
we can use as an attachment anchor.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_cam_facemesh">
<code class="descname">get_cam_facemesh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_cam_facemesh" title="Permalink to this definition">¶</a></dt>
<dd><p>get the camera targeted to the HeadMesh and return as an mNode</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_cam_rig">
<code class="descname">get_cam_rig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_cam_rig" title="Permalink to this definition">¶</a></dt>
<dd><p>get the camera targeted to the Facial Control Board
and return as an mNode</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.cam_states_get">
<code class="descname">cam_states_get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.cam_states_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get the base transforms used to setup the camera
positions up when framing the modelPanels.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>There are 3 posibilities here :</p>
<ul class="simple">
<li>the mNode has internal “cam_states” stored set via the self.cam_states_set</li>
<li>the _initial_cam_states in the __init__  has the ‘actual’ values setup which in turn disables the viewFit call</li>
<li>the _initial_cam_states in the __init__ only has the ‘initial’ key setup, used to position the camera prior to running a viewFit</li>
</ul>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_cam_states</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ui&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;initial&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">55</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;actual&#39;</span><span class="p">:</span> <span class="p">[]},</span>
<span class="gp">&gt;&gt;&gt; </span>                           <span class="s1">&#39;mesh&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;initial&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;actual&#39;</span><span class="p">:</span> <span class="p">[]}}</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.cam_states_set">
<code class="descname">cam_states_set</code><span class="sig-paren">(</span><em>mode='both'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.cam_states_set" title="Permalink to this definition">¶</a></dt>
<dd><p>push the current camera states to the internal attr</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.add_cam_facemesh">
<code class="descname">add_cam_facemesh</code><span class="sig-paren">(</span><em>focus=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.add_cam_facemesh" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new camera constrained to the “JNT_FaceRoot” in the system</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.add_cam_rig">
<code class="descname">add_cam_rig</code><span class="sig-paren">(</span><em>focus=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.add_cam_rig" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new camera parented to the “ctrl_main” node in the system</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.frame_cam_rig">
<code class="descname">frame_cam_rig</code><span class="sig-paren">(</span><em>camera=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.frame_cam_rig" title="Permalink to this definition">¶</a></dt>
<dd><p>to overload, simple focus call to put the camera in the right place,
should be framed to focus all controllers in the fRig system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>camera</strong> – if given we frame this camera, else we frame the actual UI camera from the facial systems</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.frame_cam_mesh">
<code class="descname">frame_cam_mesh</code><span class="sig-paren">(</span><em>imageplane=True</em>, <em>forcefit=False</em>, <em>camera=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.frame_cam_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>to overload, simple focus call to put the camera in the right place,
should be framed to focus on the Head meshes - “renderMeshes”</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>imageplane</strong> – if True then we include the bound imagePlane/ planes in the viewFit nodes</li>
<li><strong>forcefit</strong> – if True we over-ride / ignore any cam_states stored on the mNode itself</li>
<li><strong>camera</strong> – if given we frame this camera, else we frame the actual UI camera from the facial systems</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return camera as string:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first last">the return is for the custom Playblast handlers</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function is used in the pro_pack.core.general Playblast handling to allow for
custom camera framing and handling per mNode class where required!</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.show_cam_panel_rig">
<code class="descname">show_cam_panel_rig</code><span class="sig-paren">(</span><em>reframe=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.show_cam_panel_rig" title="Permalink to this definition">¶</a></dt>
<dd><p>isolate the face board for the camera view and set the panel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reframe</strong> – auto reframe the camera on the facial controls</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.show_cam_panel_facemesh">
<code class="descname">show_cam_panel_facemesh</code><span class="sig-paren">(</span><em>reframe=False</em>, <em>imageplane=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.show_cam_panel_facemesh" title="Permalink to this definition">¶</a></dt>
<dd><p>isolate the face board for the camera view and set the panel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reframe</strong> – auto reframe the camera on the facial mesh / imageplace</li>
<li><strong>imageplane</strong> – bool : if True we include any connected imageplanes in the framing of the camera</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.delete_cam_panel_rig">
<code class="descname">delete_cam_panel_rig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.delete_cam_panel_rig" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.delete_cam_panel_facemesh">
<code class="descname">delete_cam_panel_facemesh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.delete_cam_panel_facemesh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane">
<code class="descname">image_plane</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>return connected imageplanes if found as ImagePlane MetaClass nodes for easy setting</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane_add">
<code class="descname">image_plane_add</code><span class="sig-paren">(</span><em>filepath=None</em>, <em>filetype=None</em>, <em>frameoffset=0</em>, <em>width=None</em>, <em>height=20</em>, <em>translates=[]</em>, <em>rotates=[]</em>, <em>scales=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add in an imagine plane for roto-scoping and/or checking against a headcam. If we’ve already run this and have an
imageplane connected these all become edit flags to manipulate it</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – filepath to the image or movie we’re binding</li>
<li><strong>filetype</strong> – [‘image’,’texture’,’movie’] if not given we work it out from the file extension</li>
<li><strong>frameoffset</strong> – the offset applied to any image sequence</li>
<li><strong>width</strong> – width of the imageplane</li>
<li><strong>height</strong> – initial height of the imageplane, default=20 as width is then calculated against the aspect ratio</li>
<li><strong>translates</strong> – if given these are the translate values applied to the imageplane’s transform after create</li>
<li><strong>rotates</strong> – if given these are the rotate values applied to the imageplane’s transform after create</li>
<li><strong>scales</strong> – if given these are the scales values applied to the imageplane’s transform after create</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane_edit">
<code class="descname">image_plane_edit</code><span class="sig-paren">(</span><em>filepath=None</em>, <em>filetype=None</em>, <em>frameoffset=None</em>, <em>width=None</em>, <em>height=20</em>, <em>translates=[]</em>, <em>rotates=[]</em>, <em>scales=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane_edit" title="Permalink to this definition">¶</a></dt>
<dd><p>add in an imagine plane for roto-scoping and/or checking against a headcam. If we’ve already run this and have an
imageplane connected these all become edit flags to manipulate it</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – filepath to the image or movie we’re binding</li>
<li><strong>filetype</strong> – [‘image’,’texture’,’movie’]</li>
<li><strong>frameoffset</strong> – the offset applied to any image sequence</li>
<li><strong>width</strong> – width of the imageplane</li>
<li><strong>height</strong> – initial height of the imageplane, default=20 as width is then calculated against the aspect ratio</li>
<li><strong>translates</strong> – if given these are the translate values applied to the imageplane’s transform after create</li>
<li><strong>rotates</strong> – if given these are the rotate values applied to the imageplane’s transform after create</li>
<li><strong>scales</strong> – if given these are the scales values applied to the imageplane’s transform after create</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane_delete">
<code class="descname">image_plane_delete</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete the imageplane node</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane_connect">
<code class="descname">image_plane_connect</code><span class="sig-paren">(</span><em>imageplane=None</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.image_plane_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect a current imagePlane to the mNode for management</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.head_instancer">
<code class="descname">head_instancer</code><span class="sig-paren">(</span><em>offset=[[23, 0, 0], [0, 55, 0]], name='facial_instances'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.head_instancer" title="Permalink to this definition">¶</a></dt>
<dd><p>instance the head renderMeshes and offset, useful for playblasts
so we can have multiple angles of the facial data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> – [[tX, tY, tZ],[rX, rY, rZ]] offset applied to the instance grp</li>
<li><strong>name</strong> – default = ‘facial_instances’, name of the top grp generated</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: get the bounding box width of the main head and use that for the offset!</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.head_instancer_get">
<code class="descname">head_instancer_get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.head_instancer_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get all current instances of the head meshes wired to self</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.head_instancer_delete">
<code class="descname">head_instancer_delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.head_instancer_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete all head_instancer nodes</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_ctrls_brows">
<code class="descname">get_ctrls_brows</code><span class="sig-paren">(</span><em>select=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_ctrls_brows" title="Permalink to this definition">¶</a></dt>
<dd><p>Get child controls wired via ‘brow’ connection attrs
Designed to be overloaded for your own facial systems</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>select</strong> – select the controllers found</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_ctrls_lips">
<code class="descname">get_ctrls_lips</code><span class="sig-paren">(</span><em>select=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_ctrls_lips" title="Permalink to this definition">¶</a></dt>
<dd><p>Get child controls wired via ‘<em>lip</em>’,’<em>funnel</em>’,’<em>pucker</em>’ connection attrs,
Designed to be overloaded for your own facial systems</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>select</strong> – select the controllers found</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_ctrls_eyes">
<code class="descname">get_ctrls_eyes</code><span class="sig-paren">(</span><em>select=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.get_ctrls_eyes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get child controls wired via ‘eye’ connection attrs,
Designed to be overloaded for your own facial systems</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>select</strong> – select the controllers found</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_set_channel">
<code class="descname">viseme_map_set_channel</code><span class="sig-paren">(</span><em>chn, fromSelected=False, min=0.02, skip=['visibility'], *args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_set_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;&lt; Red9 Internal LipSyncer calls Only &gt;&gt;</p>
<p>set the selected controllers data to the visemeMap as a key pose.
Note that we store the data as (plug,attr,val) so that it’s totally
generic at the core level. We convert back to dag path in the LipSyncer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chn</strong> – channel in the map to set the data for</li>
<li><strong>fromSelected</strong> – only set the data from the selected ctrls, else set from all ctrls</li>
<li><strong>min</strong> – minimum attr value that’s considered as an input</li>
<li><strong>skip</strong> – channels to ignore in any visemeMap, default=[‘visibility’]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: if we have a zero pose compare against that as a last resort to prevent unwanted data</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_set_exclusion">
<code class="descname">viseme_map_set_exclusion</code><span class="sig-paren">(</span><em>chns=[]</em>, <em>remove=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_set_exclusion" title="Permalink to this definition">¶</a></dt>
<dd><p>if given we add the chns [‘node.attr’, …] to the exclusion
list so they won’t get processed by TalkBack. If none are given
we use the currently selected ChannelBox attrs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chns</strong> – [‘node.attr’, …] if given these are the channels to add to the
exclusion list, else we use the currently selected channelBox attrs</li>
<li><strong>remove</strong> – if True we’re removing the channels from the exemption list rather than adding</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the nodes have to be wired to the mFnode as child controllers</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_get_channels">
<code class="descname">viseme_map_get_channels</code><span class="sig-paren">(</span><em>asPlug=True</em>, <em>incTargetjnts=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_get_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;&lt; Red9 Internal LipSyncer calls Only &gt;&gt;</p>
<p>the main viseme keys will form the pose to get to that shape, these
values are then mixed up and down by the keyer based on the phoneme energy
and the particularly phoneme calibrate within that viseme.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>asPlug</strong> – if True return the visemeMap as it’s stored, else process it
such that {key:(ctrl.attr, val)}</li>
<li><strong>incTargetjnts</strong> – if True we dynamically add the target joints which
have been created to the visemeMap data</li>
<li><strong>incTargetjnts</strong> – include driven target joints in the output…. these
are simple transfer jnts connected the system and driven 0-100 range
so that we can output the data to Unity, see TalkBack.add_driver_jnts utility</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it’s here that we deal with any “lipsync_exempt” channels which will get stripped
from the return data and therefore by-pass TalkBack’s keyers</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_test_channel">
<code class="descname">viseme_map_test_channel</code><span class="sig-paren">(</span><em>channel</em>, <em>setdata=True</em>, <em>corechns=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_test_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>set the viseme channels pose to the rig and return the appropriate data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>channel</strong> – visemeMap channel to load</li>
<li><strong>setdata</strong> – load or just return the data</li>
<li><strong>corechns</strong> – if True then the return will be active core SDK channels only
if False we return the actual rig controllers</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_get_controllers">
<code class="descname">viseme_map_get_controllers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_get_controllers" title="Permalink to this definition">¶</a></dt>
<dd><p>return a list of ALL rig controllers that contribute
to the accumulated viseme map and so are part of the lipSync</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_get_sdkchannels">
<code class="descname">viseme_map_get_sdkchannels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_get_sdkchannels" title="Permalink to this definition">¶</a></dt>
<dd><p>return a list of ALL the FacialCore SDK channels that are
active during the visemeMap</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_remove_nodes">
<code class="descname">viseme_map_remove_nodes</code><span class="sig-paren">(</span><em>chn</em>, <em>nodes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_remove_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;&lt; Red9 Internal LipSyncer calls Only &gt;&gt;</p>
<p>remove the given controls from a visemeMap channel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chn</strong> – given viseme chn in the visemeMap</li>
<li><strong>nodes</strong> – if given only remove those nodes from the visemeMap chn</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_save">
<code class="descname">viseme_map_save</code><span class="sig-paren">(</span><em>filepath</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_save" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;&lt; Red9 Internal LipSyncer calls Only &gt;&gt;</p>
<p>save the visemeMap out to file</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_load">
<code class="descname">viseme_map_load</code><span class="sig-paren">(</span><em>filepath</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_load" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;&lt; Red9 Internal LipSyncer calls Only &gt;&gt;</p>
<p>load a visemeMap back in from file</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_validate">
<code class="descname">viseme_map_validate</code><span class="sig-paren">(</span><em>fix=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.viseme_map_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>validate that the viseme map is still valid, channels in the rig may have changed
which would render some of the data invalid</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.parallel_eval_get_nodes">
<code class="descname">parallel_eval_get_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI.parallel_eval_get_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>get nodes within the rig that we know to be expensive in computation
so that we can mute these in parallel eval as required for playback speed</p>
<p>this is used primarily when switching systems visibility off such as toggling
the facial rig vis state. In 2016 when a hierarchy is not visibility it IS STILL
being computed by the evalmanager, this way we freeze the returned nodes to
return that framerate back to the user.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">in Maya 2020 managing the frozen attrs in referenced files is VERY BUGGY and may be removed in future releases</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Facial_MetaHuman">
<em class="property">class </em><code class="descname">Pro_MetaRig_Facial_MetaHuman</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Facial_MetaHuman" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI</span></code></a></p>
<p>MetaRig subclass for MetaHuman Facial Rig - binds to the ExportTag_Facial_MetaHuman class</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Facial_MetaHuman.getChildren">
<code class="descname">getChildren</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_Facial_MetaHuman.getChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>we don’t return the ctrl_main for this setup</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ProMetaFacialUI">
<em class="property">class </em><code class="descname">ProMetaFacialUI</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ProMetaFacialUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_FacialUI</span></code></a></p>
<p>LEGACY TO BE REMOVED</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.Red9_MetaRig">
<em class="property">class </em><code class="descname">Red9_MetaRig</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.Red9_MetaRig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig</span></code></a></p>
<p>LEGACY TO BE REMOVED</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.SRC_RigExtension">
<em class="property">class </em><code class="descname">SRC_RigExtension</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SRC_RigExtension" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC" title="Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.Pro_MetaRig_SRC</span></code></a></p>
<p>LEGACY TO BE REMOVED</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.metadata_pro.addExportNode">
<code class="descname">addExportNode</code><span class="sig-paren">(</span><em>node</em>, <em>exportClass</em>, <em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.addExportNode" title="Permalink to this definition">¶</a></dt>
<dd><p>add an ExportTag to a given node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – node to bind the export tag to</li>
<li><strong>exportClass</strong> – class of tag to generate and link</li>
<li><strong>tag</strong> – name for the tag</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO : add MetaRig handling and checking</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base">
<em class="property">class </em><code class="descname">ExportTag_Base</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../red9core_templates/Red9_Meta.html#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>Generic Export base class inheriting from MetaClass. This is designed as a tagging system for assets
that are then time managed via the ExportLoopNodes attached. Design is such that a rig would have a single
exportTag, denoting asset name, base paths, root export joint, any suffix or prefix handling and any number
of other key aspects regarding how that rig/asset is handled within a clients pipelines.</p>
<p>Hanging from the ExportTag would be individual exportLoops that tell the export managers what timeranges to process,
where the files should get stored, what they get called etc.</p>
<p>key internal vars to note:</p>
<ul class="simple">
<li><strong>self.resolvedpath</strong> : this will be built up in any logic from custom exporter handlers</li>
<li><strong>self.subfolder</strong> : if data then we insert the entry as a sub-folder from the main exportRoot so ‘my/export/path’ =  ‘my/export/path/subfolder</li>
<li><strong>self.loop_prefix</strong> : if data then we prefix any loop-names when we resolve paths - so ‘my_walk.icaf’ loop = ‘prefix_my_walk.icaf’</li>
<li><strong>self.loop_suffix</strong> : if data then we suffix any loop-names when we resolve paths - so ‘my_walk.icaf’ loop = ‘my_walk_suffix.icaf’</li>
<li><strong>self.exportLoopBase_class</strong> = ExportLoopNode  : class we generate for exportLoops, used so that this can be overloaded for client specific behaviour</li>
<li><strong>self.audio_allowed</strong>  : determines if AudioGrp management is allowed on this class of tag</li>
</ul>
<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.override_attr_selection">
<code class="descname">override_attr_selection</code><em class="property"> = 'R9Exp_selection_override'</em><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.override_attr_selection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.override_attr_binduserattrs">
<code class="descname">override_attr_binduserattrs</code><em class="property"> = 'R9Exp_bindattrs_override'</em><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.override_attr_binduserattrs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Validation methods to run prior to processing
this export tag</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.tagType">
<code class="descname">tagType</code><span class="sig-paren">(</span><em>short=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.tagType" title="Permalink to this definition">¶</a></dt>
<dd><p>simple code to return the tags type based on it’s class inheritance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">‘CHARACTER’,’FACIAL’,’PROP’,’ENVIRONMENT’ or ‘BASE’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.export_nodetypes">
<code class="descname">export_nodetypes</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.export_nodetypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.mrig">
<code class="descname">mrig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.mrig" title="Permalink to this definition">¶</a></dt>
<dd><p>return the parent mRig to this ExportTag</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">mNode</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=0</em>, <em>encode_objects=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>info block gather for the export systems</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;mClass&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">super</span><span class="p">(</span><span class="n">ExportTag_Base</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">gatherInfo</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;tagID&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tagID</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;isActive&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">isActive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;exportPath&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exportPath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;exportRoot_specific&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exportRoot_specific</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;audioGrp&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioGrp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;exportLoops&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exportLoops</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;exportLoops&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">loopname</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;subfolder&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subfolder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;loop_prefix&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_prefix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;loop_suffix&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_suffix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;userinfo&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">userinfo</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.consumeInfo">
<code class="descname">consumeInfo</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.consumeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>given a block of data written out by the gatherInfo call above, rebuild the data on the current node instance</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.getNodes">
<code class="descname">getNodes</code><span class="sig-paren">(</span><em>select=True</em>, <em>filterSettings=None</em>, <em>include_basenodes=True</em>, <em>include_exportMeshes=None</em>, <em>include_rendermeshes=None</em>, <em>include_renderMeshes_head=None</em>, <em>include_skinned_meshes=None</em>, <em>include_blends=None</em>, <em>include_hik=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.getNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrap for the Exporter handling where we need to select everything
required for the export, including the skeleton, skinned geo, blendshapes and their targets
This works from those objects passed to it from expTag.__getNodes__() allowing you to
modify the very base behaviour at the class level if required</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the return from  this function is what you see when you launch the set specific export root
from the ExportTagUI and what gets selected when you do an FBX selective export</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>select</strong> – do we select the returned nodes?</li>
<li><strong>include_basenodes</strong> – include all nodes returned from self.__getNodes__ which for CharacterTags is all child jnts.
note that this respects the over-rides available on self and set by the selection_override_add calls</li>
<li><strong>include_exportMeshes</strong> – New management of exportMeshes, if this is True and self.exportMeshes has data we ONLY include those meshes,
if self.exportMeshes isn’t wired then we revert to previous behvaiour, inspecting the renderMeshes</li>
<li><strong>include_rendermeshes</strong> – include meshes wired to the renderMeshes attr on the mRig itself</li>
<li><strong>include_renderMeshes_head</strong> – include meshes wired to the renderMeshes_head attr on the mRig itself</li>
<li><strong>include_skinned_meshes</strong> – include all skinned meshes found to be connected the wired skeleton hierarchy</li>
<li><strong>include_blends</strong> – include any blendshapes and their respective targets if found in the scene</li>
<li><strong>include_hik</strong> – include the connected HIKCharacterNode in the return / selection if bound</li>
<li><strong>filterSettings</strong> – takes a r9Core.FilterSettings class object and allows for very specific node selection if needed</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: run the health checker on the blendshape target list to ensure we don’t have empty index slots</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_add">
<code class="descname">selection_override_add</code><span class="sig-paren">(</span><em>nodes</em>, <em>state=False</em>, <em>mode=2</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_add" title="Permalink to this definition">¶</a></dt>
<dd><p>A way of by-passing the getNode logic by adding specific
marker attr to nodes under the hierarchy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to add the override behaviour too</li>
<li><strong>state</strong> – initial state of the override</li>
<li><strong>mode</strong> – 0, 1 or 2 where 0 manages markers on the joint, 1 is internal data and 2 is auto determined by the existance of self.R9Exp_selection_override</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_is_internal">
<code class="descname">selection_override_is_internal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_is_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>simple return to denote if the selection override is internal
to the exportTag OR simple jnt only markers</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_get">
<code class="descname">selection_override_get</code><span class="sig-paren">(</span><em>exportRoot=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_get" title="Permalink to this definition">¶</a></dt>
<dd><p>return a dic of nodes that are to be either force included, or excluded
from any processed node list</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exportRoot</strong> – if given we bypass the connected default self.exportRoot
and search this new skeleton hierarchy</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_remove">
<code class="descname">selection_override_remove</code><span class="sig-paren">(</span><em>nodes=None</em>, <em>all=False</em>, <em>mode=2</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove any override marker on the given nodes, if no nodes are passed
we delete ALL overrides under the full hierarchy from the exportRoot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to remove the tags from</li>
<li><strong>all</strong> – if True we skip the nodes arg and strip all override tags from the entire skeleton</li>
<li><strong>mode</strong> – 0, 1 or 2 where 0 manages markers on the joint, 1 is internal data and 2 is auto determined by the existance of self.R9Exp_selection_override</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_set">
<code class="descname">selection_override_set</code><span class="sig-paren">(</span><em>nodes</em>, <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_set" title="Permalink to this definition">¶</a></dt>
<dd><p>change the state of the override marker on the given nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to change the override state for</li>
<li><strong>state</strong> – the state of the override to modify, ie, include or exclude driven by True or False</li>
<li><strong>mode</strong> – if True then the override data is stored on the exportTag itself, not the joints.
this allows for multiple exportTag to have different excluded nodes, mainly designed for Body+Facial
where the facial skeleton is part of the body skeleton and you just need to carefully isolate it in the exports</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_convert_to">
<code class="descname">selection_override_convert_to</code><span class="sig-paren">(</span><em>internal=True</em>, <em>exportRoot=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.selection_override_convert_to" title="Permalink to this definition">¶</a></dt>
<dd><p>convert the current set of overides from either jnt based to internal or visa versa</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>internal</strong> – if True we’re converting to internal else reverting to jnt based</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.bind_override_add">
<em class="property">classmethod </em><code class="descname">bind_override_add</code><span class="sig-paren">(</span><em>nodes</em>, <em>state=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.bind_override_add" title="Permalink to this definition">¶</a></dt>
<dd><p>A way of by-passing the default binding of attrs during the
simple FBX output. By default only transform data is exported, this adds a marker 
to the given nodes that will then include all user defined attrs from this joint in the export</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to add the override behaviour too</li>
<li><strong>state</strong> – initial state of the override</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.bind_override_get">
<code class="descname">bind_override_get</code><span class="sig-paren">(</span><em>exportRoot=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.bind_override_get" title="Permalink to this definition">¶</a></dt>
<dd><p>return a list of nodes with the bind_override marker, denoting that
their user defined attrs should also be included in exports</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exportRoot</strong> – if given we bypass the connected default self.exportRoot</td>
</tr>
</tbody>
</table>
<p>and search this new skeleton hierarchy</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.bind_override_remove">
<code class="descname">bind_override_remove</code><span class="sig-paren">(</span><em>nodes=None</em>, <em>all=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.bind_override_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove any bind override marker on the given nodes, if no nodes are passed
we delete ALL bind overrides under the full hierarchy from the exportRoot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to remove the tags from</li>
<li><strong>all</strong> – if True we skip the nodes arg and strip all override tags from the entire skeleton</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.bpose_get_data">
<code class="descname">bpose_get_data</code><span class="sig-paren">(</span><em>jntonly=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.bpose_get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>simple wrap of the retrieval of the BPose PoseDict object which is 
stored on the skeleton root by the RigManager. This BPose is used
by the additive fbx export to force reset the skeleton pose before processing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>jntonly</strong> – if True we return only the joint that the bpose is stamped onto, else we return the poseDict itself</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.bpose_load">
<code class="descname">bpose_load</code><span class="sig-paren">(</span><em>custom_root=None</em>, <em>skip_attrs=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.bpose_load" title="Permalink to this definition">¶</a></dt>
<dd><p>load the current exportRoot’s “bpose” which should be stored as an attr on the root  node either from the RigManager UI,
or useing the bpose_save func from this class. This is used in the export process when we’re exporting additive style data
to reset the export hierarchy back to bpose as required</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>custom_root</strong> – if given this loads the stored Bpose onto that skeleton,
else the data is run on self.exportRoot connection. Note that this is a simple attr
load so if the joints are connected or constrained then they won’t reach the Bpose data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.bpose_save">
<code class="descname">bpose_save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.bpose_save" title="Permalink to this definition">¶</a></dt>
<dd><p>save the current skeleton pose to the “bpose” attr on the ExportRoot node. This wraps the main
functions in the rigutils.py module which the RigManager uses internally</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.build_skeleton_for_output">
<code class="descname">build_skeleton_for_output</code><span class="sig-paren">(</span><em>bindscales=True</em>, <em>respect_attrlocks=True</em>, <em>exploop=None</em>, <em>hikcast=False</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.build_skeleton_for_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Main call to build the export skeleton for the FBX Export handler.
This is only called in the “simple” fbx output process within the exporter.
Now exposed on the Tags so we can overload for clients and expTag types as required.
Result of this is should be a bound, duplicated, clean skeleton hierarchy in
world space ready to push to FBX.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>exploop</strong> – if passed we also take the ExpLoop settings into account when we bind, else we use the ExpTag data only</li>
<li><strong>bindscales</strong> – bind the scales between the source and output skeleton</li>
<li><strong>respect_attrlocks</strong> – if True we respect locked attrs and do not bind the data to them</li>
<li><strong>hikcast</strong> – if the source skeleton has a valid HIK definition AND a valid “tpose” attr, created by the RigManager, then this
will cast that hik characterization over to the new skeleton so that the hik goes with the exports.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>[[mNode(new_skeleton_root), (mNode(additional_nodes_required_for_export), …], [str(node_to_delete), str(…], hiknode]</p>
<div class="line-block">
<div class="line">where the the first list in the return is a list of mNodes that will get selected by the exporter for output             and the second is a list of temporary nodes, str dag paths, created during this process to delete after the export has run.</div>
</div>
<p>The third is the hikNode created during the process, else None</p>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>the following are crucial internal variables found on the ExportTag and ExportLoop nodes being processed here:</p>
<ul class="last simple">
<li><strong>‘blend_map’</strong>: False  - if the mRig system has blendshapes then cast the blendShape target attrs over to driven joint attrs</li>
<li><strong>‘blendtarget’</strong>: str  - if we’re running the blend_map then this dictates the output. “rootjnt” will bind all blendtargets as                                     new attrs on the exportRoot jnt. “childjnts” is similar except each blendnode found will be hooked                                     to a new childjoint of the exportRoot. “meshes” will create a dummy mesh with duplicate blank blendtargets                                     for output (Unity as target usually)</li>
<li><strong>‘blend_maprange’</strong>: 1 - if blend_map then this is the value used as the max output only relative to the blendtarget joint methods</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.addTimeRange">
<code class="descname">addTimeRange</code><span class="sig-paren">(</span><em>times=()</em>, <em>loopname=''</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.addTimeRange" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new timerange node to this ExportTag, these are the actual
mNodes that our exporters use to trigger each individual output</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>times</strong> – (start,end) float values of times</li>
<li><strong>loopname</strong> – loopID used for export file name</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.connectTimeRanges">
<code class="descname">connectTimeRanges</code><span class="sig-paren">(</span><em>loops</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.connectTimeRanges" title="Permalink to this definition">¶</a></dt>
<dd><p>connect / cast current timerange nodes to this expTag. Note that we verify that the class
of each loop matches the expected internal exportLoopBase_class bound to this expTag class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>loops</strong> – instantiated ExportLoop nodes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.loopNameExists">
<code class="descname">loopNameExists</code><span class="sig-paren">(</span><em>loopname</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.loopNameExists" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the loopName about to be used exists</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>loopname</strong> – the name of the loop were searching for</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.getTimeRanges">
<code class="descname">getTimeRanges</code><span class="sig-paren">(</span><em>loopnames=[]</em>, <em>filter=''</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.getTimeRanges" title="Permalink to this definition">¶</a></dt>
<dd><p>get connected exportLoop nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>loopnames</strong> – [] if given this acts as a filter to return only matching loop names on this expTag</li>
<li><strong>filter</strong> – this is a more generic filter that passes through the r9Core.filterListByString() function</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.getExportLoops">
<code class="descname">getExportLoops</code><span class="sig-paren">(</span><em>loopnames=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.getExportLoops" title="Permalink to this definition">¶</a></dt>
<dd><p>renamed func call for the getTimeRanges</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.delete_export_loops">
<code class="descname">delete_export_loops</code><span class="sig-paren">(</span><em>loopnames=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.delete_export_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>delete export loops that match the filter, or delete all</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>loopnames</strong> – names passed into the search for deletion, if empty we delete all export loops connected</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.set_maya_timeranges">
<code class="descname">set_maya_timeranges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.set_maya_timeranges" title="Permalink to this definition">¶</a></dt>
<dd><p>set the Maya timeline to reflect the extent of the export loops</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.audioGrp_add">
<code class="descname">audioGrp_add</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.audioGrp_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a child AudioGrp node to manage linked audio for this tag. We use
this to manage who in the scene is talking what lines of dialog</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.audioGrp_connect">
<code class="descname">audioGrp_connect</code><span class="sig-paren">(</span><em>audioGrp</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.audioGrp_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect a current instance of an audioGrp node to self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>audioGrp</strong> – audioGrp node we’re wanting to connect</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Base.attach_asset">
<code class="descname">attach_asset</code><span class="sig-paren">(</span><em>asset_tag</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base.attach_asset" title="Permalink to this definition">¶</a></dt>
<dd><p>connect a current instance of an ExportTag node to self as attachment</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>asset_tag</strong> – aset tag to attach</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Character">
<em class="property">class </em><code class="descname">ExportTag_Character</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Character" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base" title="Red9.pro_pack.core.metadata_pro.ExportTag_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.ExportTag_Base</span></code></a></p>
<p>Export subclass for characters</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Facial">
<em class="property">class </em><code class="descname">ExportTag_Facial</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Facial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base" title="Red9.pro_pack.core.metadata_pro.ExportTag_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.ExportTag_Base</span></code></a></p>
<p>Export subclass for Facial UI systems</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Facial_MetaHuman">
<em class="property">class </em><code class="descname">ExportTag_Facial_MetaHuman</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Facial_MetaHuman" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Facial" title="Red9.pro_pack.core.metadata_pro.ExportTag_Facial"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.ExportTag_Facial</span></code></a></p>
<p>Export subclass for MetaHuman Facial UI systems to output the poly ctrls rather than the joints</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Facial_MetaHuman.build_skeleton_for_output">
<code class="descname">build_skeleton_for_output</code><span class="sig-paren">(</span><em>bindscales=True</em>, <em>respect_attrlocks=True</em>, <em>exploop=None</em>, <em>hikcast=False</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Facial_MetaHuman.build_skeleton_for_output" title="Permalink to this definition">¶</a></dt>
<dd><p>overload for MetaHuman facial export to allow us to choose if we just select
the Facial CTRL’s to pass to the exporter, if we do a standard joint based output of the facial skeleton,
OR just output the static root jnt with the expression channels mapped over</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Prop">
<em class="property">class </em><code class="descname">ExportTag_Prop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base" title="Red9.pro_pack.core.metadata_pro.ExportTag_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.ExportTag_Base</span></code></a></p>
<p>Export subclass for props</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Prop.get_attachment_node">
<code class="descname">get_attachment_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Prop.get_attachment_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Prop.build_skeleton_for_output">
<code class="descname">build_skeleton_for_output</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Prop.build_skeleton_for_output" title="Permalink to this definition">¶</a></dt>
<dd><p>overload method for the generation of the clean skeleton
that the ‘simple’ fbx exporter uses in it’s output. 
Prime reason is to allow the prop exports to remove all
root animation and reset the root joint back to [0,0,0] if
the ‘strip_root_animation’ checkbox on the PropTag is set</p>
<p>:return [mNode(new_skeleton_root), nodes_to_delete]</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Vehicle">
<em class="property">class </em><code class="descname">ExportTag_Vehicle</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Vehicle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base" title="Red9.pro_pack.core.metadata_pro.ExportTag_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.ExportTag_Base</span></code></a></p>
<p>Export subclass for vehicles</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_RigidBody">
<em class="property">class </em><code class="descname">ExportTag_RigidBody</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_RigidBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base" title="Red9.pro_pack.core.metadata_pro.ExportTag_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.ExportTag_Base</span></code></a></p>
<p>Export subclass for rigid body style outputs, These are NON SKELETAL</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_RigidBody.build_skeleton_for_output">
<code class="descname">build_skeleton_for_output</code><span class="sig-paren">(</span><em>bindscales=True</em>, <em>respect_attrlocks=True</em>, <em>exploop=None</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_RigidBody.build_skeleton_for_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Main call to build the export nodes for the FBX Export handler.
This is only called in the “simple” fbx output process within the exporter.
Now exposed on the Tags so we can overload for clients and expTag types as required.
Result of this is should be a bound, duplicated, clean skeleton hierarchy in
world space ready to push to FBX.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">unlike the ExportTag_Character and most of the other base export classes, this is a RigidBody export call,
expecting to output nodetypes matching self.export_nodetypes, which in this case is set to “locator”</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>exploop</strong> – if passed we also take the ExpLoop settings into account when we bind, else we use the ExpTag data only</li>
<li><strong>bindscales</strong> – bind the scales between the source and output skeleton</li>
<li><strong>respect_attrlocks</strong> – if True we respect locked attrs and do not bind the data to them</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[[mNode(new_skeleton_root), (mNode(additional_nodes_required_for_export), …], [nodes_to_delete]]
where the the first list in the return is a list of mNodes that will get selected by the exporter for output
and the second is a list of temporary nodes created during this process to delete after the export has run</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>when dealing with the RigidBody Export class the RigManager’s BPose handling will be redundant as we’re not locked to
nodes of type “joint”. In order to save the “bpose” attr used by the reset skeleton and “strip_root_motion” flags you need
to manually save the bpose using the following code.</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">=</span><span class="n">r9Meta</span><span class="o">.</span><span class="n">getMetaRigs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">exportTag</span><span class="o">.</span><span class="n">bpose_save</span><span class="p">()</span>
</pre></div>
</div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportTag_Environment">
<em class="property">class </em><code class="descname">ExportTag_Environment</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Red9.pro_pack.core.metadata_pro.ExportTag_Base" title="Red9.pro_pack.core.metadata_pro.ExportTag_Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.pro_pack.core.metadata_pro.ExportTag_Base</span></code></a></p>
<p>Export subclass for environments</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode">
<em class="property">class </em><code class="descname">ExportLoopNode</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../red9core_templates/Red9_Meta.html#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>Base Export Timerange node, intended to hook to a valid ExportTag metaNode to define
exact timeranges and paths etc. This is the core of the Red9 Export systems and designed to be
pverloaded at the client level where needed. This class controls the output paths and all path
logic used by the export classes.</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=0</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>gather key info on this loop node and return a dic</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># base data handling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;mClass&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">super</span><span class="p">(</span><span class="n">ExportLoopNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">gatherInfo</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;loopname&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loopname</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;loopname_resolved&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loopname_resolved</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;startFrame&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">startFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;endFrame&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;isActive&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">isActive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;exportPath&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exportPath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;exportPath_resolved&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getExportPath</span><span class="p">()</span>  <span class="c1"># resolved export path from the loops logic call</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;exportRoot_resolved&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRootNode</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;exportRoot_specific&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exportRoot_specific</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">additive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;userinfo&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">userinfo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasAttr</span><span class="p">(</span><span class="s1">&#39;skeletonAlias&#39;</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skeletonAlias&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeletonAlias</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The r9Anim postLaod functions that rebuild the exportLoops rely
on the structure of this data so if we change it that will also need
to be modified to reflect it</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.consumeInfo">
<code class="descname">consumeInfo</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.consumeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>From the data gathered reset all the vars to self from this data.
Allows us to record the data and reconstruct it in a consistent manner</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> – data to consume in a form of a correctly formatted dict,
generated by the gatherInfo call itself</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.getRootNode">
<code class="descname">getRootNode</code><span class="sig-paren">(</span><em>allowMulti=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.getRootNode" title="Permalink to this definition">¶</a></dt>
<dd><p>from the loopNode return the exportRoot from the main Tag. This is a wrapper
so that exporters can just get all the loopNodes and grab all data directly
rather than lots of walking logic</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>allowMulti</strong> – if True we allow multiple exportRoots, used only when setting up Specific Root Jnts</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.loopname_resolved">
<code class="descname">loopname_resolved</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.loopname_resolved" title="Permalink to this definition">¶</a></dt>
<dd><p>return the loopname in a resolved manner, taking into account any
prefix or suffix handling set on it’s parent exportTag class</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the loopname is “&lt;filename&gt;” then the loopname will be automatically synced to the
current Maya Scene Name and the &lt;filename&gt; will be replaced in the loopname with the Maya SceneName</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.setLoopName">
<code class="descname">setLoopName</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.setLoopName" title="Permalink to this definition">¶</a></dt>
<dd><p>this is a wrapper to be used instead of setting self.loopname directly.
The reason is that this first goes through the resolve function to see if we need to
append/prepend the loopname with anything, ie, name == name_face. It also validates the
string, removing invalid characters, and checks for duplicate names, managing copy_naming</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> – the name to set the loopname attr too</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.set_colour">
<code class="descname">set_colour</code><span class="sig-paren">(</span><em>colour</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.set_colour" title="Permalink to this definition">¶</a></dt>
<dd><p>set the colour, making sure that we always push 4 values and the last one is the alpha.
if any of the values are -1 then these are ignored when used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>colour</strong> – colour used in the UI to colour each widget [r, g, b] all ints although we
do carefully manage the data being set here to force it to a list of ints  any values
of -1 means that the data is empty or unused</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.getExportFile">
<code class="descname">getExportFile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.getExportFile" title="Permalink to this definition">¶</a></dt>
<dd><p>get the full file name, this is built from running the
getExportPath and catenating the loop_name to the end + the exportTags
internal var self.export_file_ext</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.getExportPath">
<code class="descname">getExportPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.getExportPath" title="Permalink to this definition">¶</a></dt>
<dd><p>base logic to grab / catenate the exportPath.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this path is without the filename, just the dir and is designed to
be over-loaded at a client level to support any bespoke project behaviour</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_r9anim">
<code class="descname">path_r9anim</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_r9anim" title="Permalink to this definition">¶</a></dt>
<dd><p>return the catenated export path for r9anim files</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_r9Anim_reset">
<code class="descname">path_r9Anim_reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_r9Anim_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any specific r9Anim path thats been set by the property</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_fbx">
<code class="descname">path_fbx</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_fbx" title="Permalink to this definition">¶</a></dt>
<dd><p>return the catenated export path for r9anim files</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_fbx_reset">
<code class="descname">path_fbx_reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_fbx_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any specific fbx path thats been set by the property</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_base">
<code class="descname">path_base</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_base" title="Permalink to this definition">¶</a></dt>
<dd><p>return the catenated export path for main export handler</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_base_reset">
<code class="descname">path_base_reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.path_base_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any specific export path thats been set by the property</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.isAdditive">
<code class="descname">isAdditive</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.isAdditive" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the additive bool if set on the tag</p>
<p>This first checks the Loop node itself, if thats set Additive we return that,
if not we then check the exportTag mNode and return it’s additive state.
Logic is that the exportTag is the parent of the loop therefore would over-load
the Loops non-additive state.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.exportRoot_specific_set">
<code class="descname">exportRoot_specific_set</code><span class="sig-paren">(</span><em>jnts=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.exportRoot_specific_set" title="Permalink to this definition">¶</a></dt>
<dd><p>this is so that when setting the exportSpecific_root we can run validation on it first</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>jnts</strong> – [] joints to set as specific root nodes for the exporters</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the joints go through the r9Core.nodes_in_hierarchy codebase so can be shortname pointers as these
are converted back to full path in the getRootNode calls. This attr is always set as a comma separated
string of shortnode names ‘nodeA,nodeB’</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.skeletonAlias">
<code class="descname">skeletonAlias</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.skeletonAlias" title="Permalink to this definition">¶</a></dt>
<dd><p>return the skeletonAlias stamped against the exportTag</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.setSampleSpace">
<code class="descname">setSampleSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.setSampleSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>set a wire to another transform that we’re going to use as the
relative space for any export. This all depends on the export of course!</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.removeSampleSpace">
<code class="descname">removeSampleSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.removeSampleSpace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.getTimeRanges">
<code class="descname">getTimeRanges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.getTimeRanges" title="Permalink to this definition">¶</a></dt>
<dd><p>get the timerange of the loop</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.setTimeRanges">
<code class="descname">setTimeRanges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.setTimeRanges" title="Permalink to this definition">¶</a></dt>
<dd><p>set the current playback timerange to this node</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.check_isActive">
<code class="descname">check_isActive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.check_isActive" title="Permalink to this definition">¶</a></dt>
<dd><p>yes we already have a bool on the node however, if the timeranges
parent exportTag is set inActive then that should over-ride the local
flag</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.timeOffset">
<code class="descname">timeOffset</code><span class="sig-paren">(</span><em>offset</em>, <em>timerange=None</em>, <em>ripple=True</em>, <em>cache_object=None</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.timeOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset the timerange data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> – offset the timerange data for this instance</li>
<li><strong>timerange</strong> – used to check if we need to offset both start and end frames or just one</li>
<li><strong>ripple</strong> – unused at the moment</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the timerange now also includes bounds that are equal to the loopnodes start and end frame,
originally we clamped it so the timerange had to be wider. We also now handle timerange=(10, None)
which will force the endFrame to always offset regardless, same with the start.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.copyLoop_to">
<code class="descname">copyLoop_to</code><span class="sig-paren">(</span><em>expTag</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.copyLoop_to" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate this exportLoop to a different exportTag system,
used for casting data between mRigs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>expTag</strong> – destination exportTag that will take the duplicated ExportLoopNode</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.bookmark_node">
<code class="descname">bookmark_node</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.bookmark_node" title="Permalink to this definition">¶</a></dt>
<dd><p>get the connected bookmark</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.bookmark_create">
<code class="descname">bookmark_create</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.bookmark_create" title="Permalink to this definition">¶</a></dt>
<dd><p>new bookmark support for Maya 2020</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.bookmark_refresh">
<code class="descname">bookmark_refresh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.bookmark_refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>run in the ui to sync the visual display of the bookmark when data changhes on self</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ExportLoopNode.bookmark_remove">
<code class="descname">bookmark_remove</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ExportLoopNode.bookmark_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>if found remove the bookmark connected to this loop</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.SceneMover">
<em class="property">class </em><code class="descname">SceneMover</code><span class="sig-paren">(</span><em>compensate_node=None</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SceneMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../red9core_templates/Red9_Meta.html#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>Scene Shift Handler : to move an entire Maya scene in world space
under a managed node</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mover</span><span class="o">=</span><span class="n">SceneMover</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mover</span><span class="o">.</span><span class="n">scene_shift</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># do your export stuff</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mover</span><span class="o">.</span><span class="n">scene_restore</span><span class="p">()</span>
</pre></div>
</div>
<p>SceneMover is a SINGLETON and there can only ever be a single instance of it,
when initialized we autogenerate a locator which becomes the root transform
for the shift</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.SceneMover.cacheTransforms">
<code class="descname">cacheTransforms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SceneMover.cacheTransforms" title="Permalink to this definition">¶</a></dt>
<dd><p>cache any initial transforms from the shiftRoot if it already exists</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.SceneMover.sceneroot">
<code class="descname">sceneroot</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SceneMover.sceneroot" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to the sceneRoot maya node itself</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.SceneMover.create_root">
<code class="descname">create_root</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SceneMover.create_root" title="Permalink to this definition">¶</a></dt>
<dd><p>when we take the instance is there already an existing SshiftRoot in the scene?
if there is then the chances are that was left on purpose so we set the delet flags off</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.SceneMover.groupAll">
<code class="descname">groupAll</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SceneMover.groupAll" title="Permalink to this definition">¶</a></dt>
<dd><p>group the nodes up under a single root node and manage then under meta</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.SceneMover.scene_shift">
<code class="descname">scene_shift</code><span class="sig-paren">(</span><em>transforms={}</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SceneMover.scene_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>actual process, group the scene nodes under subgrps and parent
to a single instance of a SceneShiftRoot node. Finally apply the
given transforms if specified</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>transforms</strong> – format: {‘translate’:(0,0,0), ‘rotate’:(0,0,0)} if given in these are
the transforms used on the node after everything has been grouped up</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.SceneMover.scene_restore">
<code class="descname">scene_restore</code><span class="sig-paren">(</span><em>reset=True</em>, <em>delete=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SceneMover.scene_restore" title="Permalink to this definition">¶</a></dt>
<dd><p>restore the scene as it was before the shift</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reset</strong> – whether we restore the scene as it originally was, or leave it in it’s shifted state</li>
<li><strong>delete</strong> – whether to fully delete the system nodes after restore</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.SceneMover.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.SceneMover.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>carefully deletion of the system</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane">
<em class="property">class </em><code class="descname">ImagePlane</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../red9core_templates/Red9_Meta.html#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>base classs to manage and setup ImagePlanes within Maya, instanciated as a MetaNode
for better back-end management and exposure of the base attributes directly on the class</p>
<p># TODO: force the AETemplate callbakcs to create the expression bindings for time</p>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=1</em>, <em>keys=[]</em>, <em>encode_objects=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>info block gather for the facialcore channel values</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.consumeInfo">
<code class="descname">consumeInfo</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.consumeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>From the data gathered reset all the vars to self from this data.
Allows us to record the data and reconstruct it in a consistent manner</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> – data to consume in a form of a correctly formatted dict,
generated by the gatherInfo call itself</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.timeOffset">
<code class="descname">timeOffset</code><span class="sig-paren">(</span><em>offset</em>, <em>timerange=None</em>, <em>ripple=True</em>, <em>cache_object=None</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.timeOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset the timerange data, generic call used by all the systems to manage mNodes and time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> – offset the timerange data for this instance</li>
<li><strong>timerange</strong> – used to check if we need to offset both start and end frames or just one</li>
<li><strong>ripple</strong> – unused at the moment</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.aspect">
<code class="descname">aspect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.aspect" title="Permalink to this definition">¶</a></dt>
<dd><p>the current image aspect ratio</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.imagesize">
<code class="descname">imagesize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.imagesize" title="Permalink to this definition">¶</a></dt>
<dd><p>return the width / height of the loaded image</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.set_width">
<code class="descname">set_width</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.set_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Maya’s imageplane handling is riddled with AETemplate callbacks triggering
a change in the width based on the height, this mimics this to a degree.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.set_height">
<code class="descname">set_height</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.set_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Maya’s imageplane handling is riddled with AETemplate callbacks triggering
a change in the width based on the height, this mimics this to a degree.</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.set_filepath">
<code class="descname">set_filepath</code><span class="sig-paren">(</span><em>filepath</em>, <em>filetype=None</em>, <em>frameoffset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.set_filepath" title="Permalink to this definition">¶</a></dt>
<dd><p>set the Imageplane up based on the AETemplate backend!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepath</strong> – filepath to the image or movie to load up</li>
<li><strong>filetype</strong> – specific filetype of the data, else we work it out from the file extension
[.avi, .mov, .mp4] = “movie”, else we assign to “image”</li>
<li><strong>frameoffset</strong> – if given this is the offfset applied to the loaded sequence</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: catch load errors when Maya can’t resolve the file because of image numbering!</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.parent_translate">
<code class="descname">parent_translate</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.parent_translate" title="Permalink to this definition">¶</a></dt>
<dd><p>translate of the parent transform of the imageplane node</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.parent_rotate">
<code class="descname">parent_rotate</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.parent_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate of the parent transform of the imageplane node</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.parent_scale">
<code class="descname">parent_scale</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.parent_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>scale of the parent transform of the imageplane node</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.ImagePlane.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.ImagePlane.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete the imageplane node and make sure we cleanup it’s parent transform</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup">
<em class="property">class </em><code class="descname">AudioGroup</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../red9core_templates/Red9_Meta.html#Red9.core.Red9_Meta.MetaClass" title="Red9.core.Red9_Meta.MetaClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaClass</span></code></a></p>
<p>a simple node designed to group / link audio sound nodes to together so they can
be linked to a character rig for export logic handling</p>
<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup.audioNodes">
<code class="descname">audioNodes</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup.audioNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>return the linked audio as instantiates r9Audio.AudioNodes objects</p>
</dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup.audioHandler">
<code class="descname">audioHandler</code><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup.audioHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>get the audioNodes linked as an r9Audio.AudioHandler object</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup.gatherInfo">
<code class="descname">gatherInfo</code><span class="sig-paren">(</span><em>level=0</em>, <em>encode_objects=False</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup.gatherInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>gather key info on this AudioGrp node and return a dic of all
connected audio node data</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup.connectAudioNodes">
<code class="descname">connectAudioNodes</code><span class="sig-paren">(</span><em>audio=[]</em>, <em>paths=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup.connectAudioNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>connect given sound nodes to the group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>audio</strong> – [] maya audio to connect to this AudioGrp</li>
<li><strong>paths</strong> – [] if we give it raw filepaths this will import and then link up to the audioGrp</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup.disconnectAudioNodes">
<code class="descname">disconnectAudioNodes</code><span class="sig-paren">(</span><em>audio</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup.disconnectAudioNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect the given audio nodes form the grp</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nodes</strong> – audio to connect to this AudioGrp</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup.getAudioNodes">
<code class="descname">getAudioNodes</code><span class="sig-paren">(</span><em>time=()</em>, <em>start_inRange=True</em>, <em>end_inRange=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup.getAudioNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>return an AudioNode object that fall within a given
timerange, if not timerange is given return all linked audio</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time</strong> – time (start, end) tuple as a range.</li>
<li><strong>start_inRange</strong> – check is the testRange[0] value falls fully in the baseRange</li>
<li><strong>end_inRange</strong> – check is the testRange[1] value falls fully in the baseRange</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if you pass in baseRange as (None, 100) then we only validate against the end time.
if we pass in baseRange as (10, None) we only validate against the start time
else we validate that testRange is fully within the baseRanges times</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup.isConnected">
<code class="descname">isConnected</code><span class="sig-paren">(</span><em>audio</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup.isConnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.AudioGroup.timeOffset">
<code class="descname">timeOffset</code><span class="sig-paren">(</span><em>offset</em>, <em>timerange=None</em>, <em>ripple=True</em>, <em>cache_object=None</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.AudioGroup.timeOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset the audio node offset data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> – offset the timerange data for this instance</li>
<li><strong>timerange</strong> – used to check if we need to offset both start and end frames or just one</li>
<li><strong>ripple</strong> – unused at the moment</li>
<li><strong>cache_object</strong> – the cache / processed list used to prevent duplicate offsets. This is usually the TimeOffset()._processed dict</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD">
<em class="property">class </em><code class="descname">MetaTimeCodeHUD</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../red9core_templates/Red9_Meta.html#Red9.core.Red9_Meta.MetaHUDNode" title="Red9.core.Red9_Meta.MetaHUDNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Red9.core.Red9_Meta.MetaHUDNode</span></code></a></p>
<p>Generate’s a HUD node connected to the main timecode attrs,
allows us to show the actual internal timecode attrs as their
original SMPTE time’s</p>
<p>Crucial things to be aware of:</p>
<p>We construct timecode from 3 attrs on the given node:
timecode_ref        : the original timecode converted to milliseconds
timecode_count      : a linear curve that increments every frame based on the samplerate
timecode_samplerate : samplerate that the linear counter was generated against</p>
<p>SMPTE timecode is then reconstructed like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r9Audio</span><span class="o">.</span><span class="n">milliseconds_to_Timecode</span><span class="p">(</span><span class="n">ref</span> <span class="o">+</span> <span class="p">((</span><span class="n">count</span> <span class="o">/</span> <span class="n">samplerate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
</pre></div>
</div>
<p>The easiest and expected way to use this class is directly from the Pro_MetaRig.Timecode class
binding in which this HUD class is managed in a correct manner. See audio.Timecode class for
more details.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">=</span><span class="n">r9Meta</span><span class="o">.</span><span class="n">getMetaRigs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">Timecode</span><span class="o">.</span><span class="n">addTimecode_to_node</span><span class="p">(</span><span class="n">tc</span><span class="o">=</span><span class="s1">&#39;01:00:00:00&#39;</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># add timecode to the mRig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mrig</span><span class="o">.</span><span class="n">Timecode</span><span class="o">.</span><span class="n">hud_connect</span><span class="p">()</span>
</pre></div>
</div>
<p>You can of course run this directly from a class instance, however, the nodes
passed to the addMonitored call have to have the timecode attrs already bound to them</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tcHUD</span><span class="o">=</span><span class="n">r9pmeta</span><span class="o">.</span><span class="n">MetaTimeCodeHUD</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tcHUD</span><span class="o">.</span><span class="n">addMonitoredTimecodeNode</span><span class="p">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">sl</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># node must have valid timecode attrs already</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tcHUD</span><span class="o">.</span><span class="n">drawHUD</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.refreshHud">
<code class="descname">refreshHud</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.refreshHud" title="Permalink to this definition">¶</a></dt>
<dd><p>Refresh the HUD by killing it and re-drawing it from scratch, we also
re-build the cached attrs for the timecode systems</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.addMonitoredTimecodeNode">
<code class="descname">addMonitoredTimecodeNode</code><span class="sig-paren">(</span><em>nodes</em>, <em>valid=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.addMonitoredTimecodeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>add a node with the TimeCode attrs on it to monitor</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.removeMonitoredTimecodeNode">
<code class="descname">removeMonitoredTimecodeNode</code><span class="sig-paren">(</span><em>nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.removeMonitoredTimecodeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a given node from the timecode</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.removeMonitoredAttr">
<code class="descname">removeMonitoredAttr</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.removeMonitoredAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a specific attr from the HUD</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.connectTimecodeSystems">
<code class="descname">connectTimecodeSystems</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.metadata_pro.MetaTimeCodeHUD.connectTimecodeSystems" title="Permalink to this definition">¶</a></dt>
<dd><p>connect all mRigs in the scene to the HUD node</p>
</dd></dl>

</dd></dl>

</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Red9_Pro_importexport.html" class="btn btn-neutral float-left" title="Pro_Pack : importexport" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Red9_Pro_optimiser.html" class="btn btn-neutral float-right" title="Pro_Pack : optimiser" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Red9 Consultancy Limited.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>